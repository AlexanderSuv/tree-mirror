!function(g){function I(C){if(n[C])return n[C].exports;var t=n[C]={i:C,l:!1,exports:{}};return g[C].call(t.exports,t,t.exports,I),t.l=!0,t.exports}var n={};return I.m=g,I.c=n,I.i=function(g){return g},I.d=function(g,I,n){Object.defineProperty(g,I,{configurable:!1,enumerable:!0,get:n})},I.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(n,"a",n),n},I.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},I.p="/",I(I.s=2)}([function(module,exports,__webpack_require__){"use strict";eval('"use strict";\n\nvar _mutationSummary = __webpack_require__(/*! ./mutation-summary */ 1);\n\nif (true) {\n    console.log(_mutationSummary.MutationSummary);\n    console.log(_mutationSummary.MutationSummary.NodeMap);\n}\n\nvar TreeMirror = function () {\n    function TreeMirror(root, delegate) {\n        this.root = root;\n        this.delegate = delegate;\n        this.idMap = {};\n    }\n    TreeMirror.prototype.initialize = function (rootId, children) {\n        this.idMap[rootId] = this.root;\n\n        for (var i = 0; i < children.length; i++) {\n            this.deserializeNode(children[i], this.root);\n        }\n    };\n\n    TreeMirror.prototype.applyChanged = function (removed, addedOrMoved, attributes, text) {\n        var _this = this;\n        // NOTE: Applying the changes can result in an attempting to add a child\n        // to a parent which is presently an ancestor of the parent. This can occur\n        // based on random ordering of moves. The way we handle this is to first\n        // remove all changed nodes from their parents, then apply.\n        addedOrMoved.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            var parent = _this.deserializeNode(data.parentNode);\n            var previous = _this.deserializeNode(data.previousSibling);\n            if (node.parentNode) node.parentNode.removeChild(node);\n        });\n\n        removed.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            if (node.parentNode) node.parentNode.removeChild(node);\n        });\n\n        addedOrMoved.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            var parent = _this.deserializeNode(data.parentNode);\n            var previous = _this.deserializeNode(data.previousSibling);\n            parent.insertBefore(node, previous ? previous.nextSibling : parent.firstChild);\n        });\n\n        attributes.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            Object.keys(data.attributes).forEach(function (attrName) {\n                var newVal = data.attributes[attrName];\n                if (newVal === null) {\n                    node.removeAttribute(attrName);\n                } else {\n                    if (!_this.delegate || !_this.delegate.setAttribute || !_this.delegate.setAttribute(node, attrName, newVal)) {\n                        node.setAttribute(attrName, newVal);\n                    }\n                }\n            });\n        });\n\n        text.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            node.textContent = data.textContent;\n        });\n\n        removed.forEach(function (node) {\n            delete _this.idMap[node.id];\n        });\n    };\n\n    TreeMirror.prototype.deserializeNode = function (nodeData, parent) {\n        var _this = this;\n        if (nodeData === null) return null;\n\n        var node = this.idMap[nodeData.id];\n        if (node) return node;\n\n        var doc = this.root.ownerDocument;\n        if (doc === null) doc = this.root;\n\n        switch (nodeData.nodeType) {\n            case Node.COMMENT_NODE:\n                node = doc.createComment(nodeData.textContent);\n                break;\n\n            case Node.TEXT_NODE:\n                node = doc.createTextNode(nodeData.textContent);\n                break;\n\n            case Node.DOCUMENT_TYPE_NODE:\n                node = doc.implementation.createDocumentType(nodeData.name, nodeData.publicId, nodeData.systemId);\n                break;\n\n            case Node.ELEMENT_NODE:\n                if (this.delegate && this.delegate.createElement) node = this.delegate.createElement(nodeData.tagName);\n                if (!node) node = doc.createElement(nodeData.tagName);\n\n                Object.keys(nodeData.attributes).forEach(function (name) {\n                    try {\n                        if (!_this.delegate || !_this.delegate.setAttribute || !_this.delegate.setAttribute(node, name, nodeData.attributes[name])) {\n                            node.setAttribute(name, nodeData.attributes[name]);\n                        }\n                    } catch (e) {\n                        // Debug here if needed\n                    }\n                });\n\n                break;\n        }\n\n        if (!node) throw "ouch";\n\n        this.idMap[nodeData.id] = node;\n\n        if (parent) parent.appendChild(node);\n\n        if (nodeData.childNodes) {\n            for (var i = 0; i < nodeData.childNodes.length; i++) {\n                this.deserializeNode(nodeData.childNodes[i], node);\n            }\n        }\n\n        return node;\n    };\n    return TreeMirror;\n}();\n\nvar TreeMirrorClient = function () {\n\n    function TreeMirrorClient(target, mirror, testingQueries) {\n        var _this = this;\n        this.target = target;\n        this.mirror = mirror;\n        this.nextId = 1;\n        this.knownNodes = new _mutationSummary.MutationSummary.NodeMap();\n\n        if (typeof this.mirror == "undefined") {\n            this.mirror = _this.getDefaultMirror();\n        }\n\n        var rootId = this.serializeNode(target).id;\n        var children = [];\n        for (var child = target.firstChild; child; child = child.nextSibling) {\n            children.push(this.serializeNode(child, true));\n        }this.mirror.initialize(rootId, children);\n\n        var self = this;\n\n        var queries = [{ all: true }];\n\n        if (testingQueries) queries = queries.concat(testingQueries);\n\n        var MutationObserverCtor;\n\n        try {\n            if (typeof WebKitMutationObserver !== \'undefined\') MutationObserverCtor = WebKitMutationObserver;else MutationObserverCtor = MutationObserver;\n        } catch (e) {\n            MutationObserverCtor = undefined;\n        };\n\n        if (MutationObserverCtor !== undefined) {\n            this.mutationSummary = new _mutationSummary.MutationSummary({\n                rootNode: target,\n                callback: function callback(summaries) {\n                    _this.applyChanged(summaries);\n                },\n                queries: queries\n            });\n        }\n    }\n\n    TreeMirrorClient.prototype.getDefaultMirror = function () {\n        return {\n            initialize: function initialize(rootId, children) {\n                return;\n            },\n            applyChanged: function applyChanged(removed, addedOrMoved, attributes, text) {\n                return;\n            }\n        };\n    };\n\n    TreeMirrorClient.prototype.disconnect = function () {\n        if (this.mutationSummary) {\n            this.mutationSummary.disconnect();\n            this.mutationSummary = undefined;\n        }\n    };\n\n    TreeMirrorClient.prototype.rememberNode = function (node) {\n        var id = this.nextId++;\n        this.knownNodes.set(node, id);\n        return id;\n    };\n\n    TreeMirrorClient.prototype.forgetNode = function (node) {\n        this.knownNodes.delete(node);\n    };\n\n    TreeMirrorClient.prototype.serializeNode = function (node, recursive) {\n        if (node === null) return null;\n\n        var id = this.knownNodes.get(node);\n        if (id !== undefined) {\n            return { id: id };\n        }\n\n        var data = {\n            nodeType: node.nodeType,\n            id: this.rememberNode(node)\n        };\n\n        switch (data.nodeType) {\n            case Node.DOCUMENT_TYPE_NODE:\n                var docType = node;\n                data.name = docType.name;\n                data.publicId = docType.publicId;\n                data.systemId = docType.systemId;\n                break;\n\n            case Node.COMMENT_NODE:\n            case Node.TEXT_NODE:\n                data.textContent = node.textContent;\n                break;\n\n            case Node.ELEMENT_NODE:\n                var elm = node;\n                data.tagName = elm.tagName;\n                data.attributes = {};\n                for (var i = 0; i < elm.attributes.length; i++) {\n                    var attr = elm.attributes[i];\n                    data.attributes[attr.name] = attr.value;\n                }\n\n                if (recursive && elm.childNodes.length) {\n                    data.childNodes = [];\n\n                    for (var child = elm.firstChild; child; child = child.nextSibling) {\n                        data.childNodes.push(this.serializeNode(child, true));\n                    }\n                }\n                break;\n        }\n\n        return data;\n    };\n\n    TreeMirrorClient.prototype.serializeAddedAndMoved = function (added, reparented, reordered) {\n        var _this = this;\n        var all = added.concat(reparented).concat(reordered);\n\n        var parentMap = new _mutationSummary.MutationSummary.NodeMap();\n\n        all.forEach(function (node) {\n            var parent = node.parentNode;\n            var children = parentMap.get(parent);\n            if (!children) {\n                children = new _mutationSummary.MutationSummary.NodeMap();\n                parentMap.set(parent, children);\n            }\n\n            children.set(node, true);\n        });\n\n        var moved = [];\n\n        parentMap.keys().forEach(function (parent) {\n            var children = parentMap.get(parent);\n\n            var keys = children.keys();\n            while (keys.length) {\n                var node = keys[0];\n                while (node.previousSibling && children.has(node.previousSibling)) {\n                    node = node.previousSibling;\n                }while (node && children.has(node)) {\n                    var data = _this.serializeNode(node);\n                    data.previousSibling = _this.serializeNode(node.previousSibling);\n                    data.parentNode = _this.serializeNode(node.parentNode);\n                    moved.push(data);\n                    children.delete(node);\n                    node = node.nextSibling;\n                }\n\n                var keys = children.keys();\n            }\n        });\n\n        return moved;\n    };\n\n    TreeMirrorClient.prototype.serializeAttributeChanges = function (attributeChanged) {\n        var _this = this;\n        var map = new _mutationSummary.MutationSummary.NodeMap();\n\n        Object.keys(attributeChanged).forEach(function (attrName) {\n            attributeChanged[attrName].forEach(function (element) {\n                var record = map.get(element);\n                if (!record) {\n                    record = _this.serializeNode(element);\n                    record.attributes = {};\n                    map.set(element, record);\n                }\n\n                record.attributes[attrName] = element.getAttribute(attrName);\n            });\n        });\n\n        return map.keys().map(function (node) {\n            return map.get(node);\n        });\n    };\n\n    TreeMirrorClient.prototype.applyChanged = function (summaries) {\n        var _this = this;\n        var summary = summaries[0];\n\n        var removed = summary.removed.map(function (node) {\n            return _this.serializeNode(node);\n        });\n\n        var moved = this.serializeAddedAndMoved(summary.added, summary.reparented, summary.reordered);\n\n        var attributes = this.serializeAttributeChanges(summary.attributeChanged);\n\n        var text = summary.characterDataChanged.map(function (node) {\n            var data = _this.serializeNode(node);\n            data.textContent = node.textContent;\n            return data;\n        });\n\n        this.mirror.applyChanged(removed, moved, attributes, text);\n\n        summary.removed.forEach(function (node) {\n            _this.forgetNode(node);\n        });\n    };\n    return TreeMirrorClient;\n}();\n\nmodule.exports = {\n    TreeMirror: TreeMirror,\n    TreeMirrorClient: TreeMirrorClient\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvdHJlZS1taXJyb3IuanM/YjZmOCIsIndlYnBhY2s6Ly8vP2Q0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTXV0YXRpb25TdW1tYXJ5IH0gZnJvbSAnLi9tdXRhdGlvbi1zdW1tYXJ5JztcblxuaWYgKF9fREVWX18pIHtcbiAgY29uc29sZS5sb2coTXV0YXRpb25TdW1tYXJ5KTtcbiAgY29uc29sZS5sb2coTXV0YXRpb25TdW1tYXJ5Lk5vZGVNYXApO1xufVxuXG52YXIgVHJlZU1pcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJlZU1pcnJvcihyb290LCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuaWRNYXAgPSB7fTtcbiAgICB9XG4gICAgVHJlZU1pcnJvci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChyb290SWQsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuaWRNYXBbcm9vdElkXSA9IHRoaXMucm9vdDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZU5vZGUoY2hpbGRyZW5baV0sIHRoaXMucm9vdCk7XG4gICAgfTtcblxuICAgIFRyZWVNaXJyb3IucHJvdG90eXBlLmFwcGx5Q2hhbmdlZCA9IGZ1bmN0aW9uIChyZW1vdmVkLCBhZGRlZE9yTW92ZWQsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTk9URTogQXBwbHlpbmcgdGhlIGNoYW5nZXMgY2FuIHJlc3VsdCBpbiBhbiBhdHRlbXB0aW5nIHRvIGFkZCBhIGNoaWxkXG4gICAgICAgIC8vIHRvIGEgcGFyZW50IHdoaWNoIGlzIHByZXNlbnRseSBhbiBhbmNlc3RvciBvZiB0aGUgcGFyZW50LiBUaGlzIGNhbiBvY2N1clxuICAgICAgICAvLyBiYXNlZCBvbiByYW5kb20gb3JkZXJpbmcgb2YgbW92ZXMuIFRoZSB3YXkgd2UgaGFuZGxlIHRoaXMgaXMgdG8gZmlyc3RcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBjaGFuZ2VkIG5vZGVzIGZyb20gdGhlaXIgcGFyZW50cywgdGhlbiBhcHBseS5cbiAgICAgICAgYWRkZWRPck1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMuZGVzZXJpYWxpemVOb2RlKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IF90aGlzLmRlc2VyaWFsaXplTm9kZShkYXRhLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gX3RoaXMuZGVzZXJpYWxpemVOb2RlKGRhdGEucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMuZGVzZXJpYWxpemVOb2RlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFkZGVkT3JNb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzLmRlc2VyaWFsaXplTm9kZShkYXRhKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpcy5kZXNlcmlhbGl6ZU5vZGUoZGF0YS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IF90aGlzLmRlc2VyaWFsaXplTm9kZShkYXRhLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHByZXZpb3VzID8gcHJldmlvdXMubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5kZXNlcmlhbGl6ZU5vZGUoZGF0YSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IGRhdGEuYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5kZWxlZ2F0ZSB8fCAhX3RoaXMuZGVsZWdhdGUuc2V0QXR0cmlidXRlIHx8ICFfdGhpcy5kZWxlZ2F0ZS5zZXRBdHRyaWJ1dGUobm9kZSwgYXR0ck5hbWUsIG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBuZXdWYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRleHQuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5kZXNlcmlhbGl6ZU5vZGUoZGF0YSk7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gZGF0YS50ZXh0Q29udGVudDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuaWRNYXBbbm9kZS5pZF07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmVlTWlycm9yLnByb3RvdHlwZS5kZXNlcmlhbGl6ZU5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobm9kZURhdGEgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaWRNYXBbbm9kZURhdGEuaWRdO1xuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgIHZhciBkb2MgPSB0aGlzLnJvb3Qub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKGRvYyA9PT0gbnVsbClcbiAgICAgICAgICAgIGRvYyA9IHRoaXMucm9vdDtcblxuICAgICAgICBzd2l0Y2ggKG5vZGVEYXRhLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGUuQ09NTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudChub2RlRGF0YS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZShub2RlRGF0YS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9UWVBFX05PREU6XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvYy5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFR5cGUobm9kZURhdGEubmFtZSwgbm9kZURhdGEucHVibGljSWQsIG5vZGVEYXRhLnN5c3RlbUlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLmNyZWF0ZUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZUVsZW1lbnQobm9kZURhdGEudGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQobm9kZURhdGEudGFnTmFtZSk7XG5cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhub2RlRGF0YS5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgXHR0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZGVsZWdhdGUgfHwgIV90aGlzLmRlbGVnYXRlLnNldEF0dHJpYnV0ZSB8fCAhX3RoaXMuZGVsZWdhdGUuc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIG5vZGVEYXRhLmF0dHJpYnV0ZXNbbmFtZV0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIG5vZGVEYXRhLmF0dHJpYnV0ZXNbbmFtZV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBcdC8vIERlYnVnIGhlcmUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgdGhyb3cgXCJvdWNoXCI7XG5cbiAgICAgICAgdGhpcy5pZE1hcFtub2RlRGF0YS5pZF0gPSBub2RlO1xuXG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGVEYXRhLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZURhdGEuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplTm9kZShub2RlRGF0YS5jaGlsZE5vZGVzW2ldLCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIFRyZWVNaXJyb3I7XG59KSgpO1xuXG52YXIgVHJlZU1pcnJvckNsaWVudCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBUcmVlTWlycm9yQ2xpZW50KHRhcmdldCwgbWlycm9yLCB0ZXN0aW5nUXVlcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gICAgICAgIHRoaXMubmV4dElkID0gMTtcbiAgICAgICAgdGhpcy5rbm93bk5vZGVzID0gbmV3IE11dGF0aW9uU3VtbWFyeS5Ob2RlTWFwKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1pcnJvciA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhpcy5taXJyb3IgPSBfdGhpcy5nZXREZWZhdWx0TWlycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdElkID0gdGhpcy5zZXJpYWxpemVOb2RlKHRhcmdldCkuaWQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IHRhcmdldC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZylcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5zZXJpYWxpemVOb2RlKGNoaWxkLCB0cnVlKSk7XG5cbiAgICAgICAgdGhpcy5taXJyb3IuaW5pdGlhbGl6ZShyb290SWQsIGNoaWxkcmVuKTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBbeyBhbGw6IHRydWUgfV07XG5cbiAgICAgICAgaWYgKHRlc3RpbmdRdWVyaWVzKVxuICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KHRlc3RpbmdRdWVyaWVzKTtcblxuICAgICAgICB2YXIgTXV0YXRpb25PYnNlcnZlckN0b3I7XG5cbiAgICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAodHlwZW9mIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKVxuXHQgICAgICAgICAgICBNdXRhdGlvbk9ic2VydmVyQ3RvciA9IFdlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cdCAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICBNdXRhdGlvbk9ic2VydmVyQ3RvciA9IE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgXHRNdXRhdGlvbk9ic2VydmVyQ3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoTXV0YXRpb25PYnNlcnZlckN0b3IgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHRoaXMubXV0YXRpb25TdW1tYXJ5ID0gbmV3IE11dGF0aW9uU3VtbWFyeSh7XG5cdCAgICAgICAgICAgIHJvb3ROb2RlOiB0YXJnZXQsXG5cdCAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoc3VtbWFyaWVzKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5hcHBseUNoYW5nZWQoc3VtbWFyaWVzKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcXVlcmllczogcXVlcmllc1xuXHQgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgVHJlZU1pcnJvckNsaWVudC5wcm90b3R5cGUuZ2V0RGVmYXVsdE1pcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocm9vdElkLCBjaGlsZHJlbil7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseUNoYW5nZWQ6IGZ1bmN0aW9uKHJlbW92ZWQsIGFkZGVkT3JNb3ZlZCwgYXR0cmlidXRlcywgdGV4dCl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgVHJlZU1pcnJvckNsaWVudC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25TdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uU3VtbWFyeS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uU3VtbWFyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUcmVlTWlycm9yQ2xpZW50LnByb3RvdHlwZS5yZW1lbWJlck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLm5leHRJZCsrO1xuICAgICAgICB0aGlzLmtub3duTm9kZXMuc2V0KG5vZGUsIGlkKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG5cbiAgICBUcmVlTWlycm9yQ2xpZW50LnByb3RvdHlwZS5mb3JnZXROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5rbm93bk5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICB9O1xuXG4gICAgVHJlZU1pcnJvckNsaWVudC5wcm90b3R5cGUuc2VyaWFsaXplTm9kZSA9IGZ1bmN0aW9uIChub2RlLCByZWN1cnNpdmUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgaWQgPSB0aGlzLmtub3duTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGlkIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG5vZGVUeXBlOiBub2RlLm5vZGVUeXBlLFxuICAgICAgICAgICAgaWQ6IHRoaXMucmVtZW1iZXJOb2RlKG5vZGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFOlxuICAgICAgICAgICAgICAgIHZhciBkb2NUeXBlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBkYXRhLm5hbWUgPSBkb2NUeXBlLm5hbWU7XG4gICAgICAgICAgICAgICAgZGF0YS5wdWJsaWNJZCA9IGRvY1R5cGUucHVibGljSWQ7XG4gICAgICAgICAgICAgICAgZGF0YS5zeXN0ZW1JZCA9IGRvY1R5cGUuc3lzdGVtSWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTm9kZS5DT01NRU5UX05PREU6XG4gICAgICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgICAgICAgIGRhdGEudGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgIHZhciBlbG0gPSBub2RlO1xuICAgICAgICAgICAgICAgIGRhdGEudGFnTmFtZSA9IGVsbS50YWdOYW1lO1xuICAgICAgICAgICAgICAgIGRhdGEuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxtLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBlbG0uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdHRyaWJ1dGVzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmUgJiYgZWxtLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY2hpbGROb2RlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gZWxtLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jaGlsZE5vZGVzLnB1c2godGhpcy5zZXJpYWxpemVOb2RlKGNoaWxkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIFRyZWVNaXJyb3JDbGllbnQucHJvdG90eXBlLnNlcmlhbGl6ZUFkZGVkQW5kTW92ZWQgPSBmdW5jdGlvbiAoYWRkZWQsIHJlcGFyZW50ZWQsIHJlb3JkZXJlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxsID0gYWRkZWQuY29uY2F0KHJlcGFyZW50ZWQpLmNvbmNhdChyZW9yZGVyZWQpO1xuXG4gICAgICAgIHZhciBwYXJlbnRNYXAgPSBuZXcgTXV0YXRpb25TdW1tYXJ5Lk5vZGVNYXAoKTtcblxuICAgICAgICBhbGwuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudE1hcC5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IG5ldyBNdXRhdGlvblN1bW1hcnkuTm9kZU1hcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudE1hcC5zZXQocGFyZW50LCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLnNldChub2RlLCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1vdmVkID0gW107XG5cbiAgICAgICAgcGFyZW50TWFwLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudE1hcC5nZXQocGFyZW50KTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBjaGlsZHJlbi5rZXlzKCk7XG4gICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGtleXNbMF07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUucHJldmlvdXNTaWJsaW5nICYmIGNoaWxkcmVuLmhhcyhub2RlLnByZXZpb3VzU2libGluZykpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcblxuICAgICAgICAgICAgICAgIHdoaWxlIChub2RlICYmIGNoaWxkcmVuLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF90aGlzLnNlcmlhbGl6ZU5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJldmlvdXNTaWJsaW5nID0gX3RoaXMuc2VyaWFsaXplTm9kZShub2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucGFyZW50Tm9kZSA9IF90aGlzLnNlcmlhbGl6ZU5vZGUobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGNoaWxkcmVuLmtleXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vdmVkO1xuICAgIH07XG5cbiAgICBUcmVlTWlycm9yQ2xpZW50LnByb3RvdHlwZS5zZXJpYWxpemVBdHRyaWJ1dGVDaGFuZ2VzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNdXRhdGlvblN1bW1hcnkuTm9kZU1hcCgpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZUNoYW5nZWQpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkW2F0dHJOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IG1hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuc2VyaWFsaXplTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldChlbGVtZW50LCByZWNvcmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlY29yZC5hdHRyaWJ1dGVzW2F0dHJOYW1lXSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWFwLmtleXMoKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAuZ2V0KG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJlZU1pcnJvckNsaWVudC5wcm90b3R5cGUuYXBwbHlDaGFuZ2VkID0gZnVuY3Rpb24gKHN1bW1hcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3VtbWFyeSA9IHN1bW1hcmllc1swXTtcblxuICAgICAgICB2YXIgcmVtb3ZlZCA9IHN1bW1hcnkucmVtb3ZlZC5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2VyaWFsaXplTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1vdmVkID0gdGhpcy5zZXJpYWxpemVBZGRlZEFuZE1vdmVkKHN1bW1hcnkuYWRkZWQsIHN1bW1hcnkucmVwYXJlbnRlZCwgc3VtbWFyeS5yZW9yZGVyZWQpO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5zZXJpYWxpemVBdHRyaWJ1dGVDaGFuZ2VzKHN1bW1hcnkuYXR0cmlidXRlQ2hhbmdlZCk7XG5cbiAgICAgICAgdmFyIHRleHQgPSBzdW1tYXJ5LmNoYXJhY3RlckRhdGFDaGFuZ2VkLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gX3RoaXMuc2VyaWFsaXplTm9kZShub2RlKTtcbiAgICAgICAgICBkYXRhLnRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5taXJyb3IuYXBwbHlDaGFuZ2VkKHJlbW92ZWQsIG1vdmVkLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcblxuICAgICAgICBzdW1tYXJ5LnJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIF90aGlzLmZvcmdldE5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRyZWVNaXJyb3JDbGllbnQ7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHJlZU1pcnJvcjogVHJlZU1pcnJvcixcbiAgVHJlZU1pcnJvckNsaWVudDogVHJlZU1pcnJvckNsaWVudFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy90cmVlLW1pcnJvci5qcyIsInVuZGVmaW5lZFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0JBO0FBQ0E7QUErQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBNUJBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBIiwic291cmNlUm9vdCI6IiJ9')},function(module,exports){"use strict";eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Copyright 2011 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar MutationObserverCtor;\n\ntry {\n    if (typeof WebKitMutationObserver !== 'undefined') MutationObserverCtor = WebKitMutationObserver;else MutationObserverCtor = MutationObserver;\n} catch (e) {\n    MutationObserverCtor = undefined;\n}\n\nvar NodeMap = function () {\n    function NodeMap() {\n        _classCallCheck(this, NodeMap);\n\n        this.nodes = [];\n        this.values = [];\n        this.ID_PROP = '__mutation_summary_node_map_id__';\n        this.nextId_ = 1;\n    }\n\n    _createClass(NodeMap, [{\n        key: 'isIndex',\n        value: function isIndex(s) {\n            return +s === s >>> 0;\n        }\n    }, {\n        key: 'nodeId',\n        value: function nodeId(node) {\n            var id = node[this.ID_PROP];\n            if (!id) id = node[this.ID_PROP] = this.nextId_++;\n            return id;\n        }\n    }, {\n        key: 'set',\n        value: function set(node, value) {\n            var id = this.nodeId(node);\n            this.nodes[id] = node;\n            this.values[id] = value;\n        }\n    }, {\n        key: 'get',\n        value: function get(node) {\n            var id = this.nodeId(node);\n            return this.values[id];\n        }\n    }, {\n        key: 'has',\n        value: function has(node) {\n            return this.nodeId(node) in this.nodes;\n        }\n    }, {\n        key: 'delete',\n        value: function _delete(node) {\n            var id = this.nodeId(node);\n            delete this.nodes[id];\n            this.values[id] = undefined;\n        }\n    }, {\n        key: 'keys',\n        value: function keys() {\n            var nodes = [];\n            for (var id in this.nodes) {\n                if (!this.isIndex(id)) continue;\n                nodes.push(this.nodes[id]);\n            }\n\n            return nodes;\n        }\n    }]);\n\n    return NodeMap;\n}();\n\nvar Movement;\n(function (Movement) {\n    Movement[Movement[\"STAYED_OUT\"] = 0] = \"STAYED_OUT\";\n    Movement[Movement[\"ENTERED\"] = 1] = \"ENTERED\";\n    Movement[Movement[\"STAYED_IN\"] = 2] = \"STAYED_IN\";\n    Movement[Movement[\"REPARENTED\"] = 3] = \"REPARENTED\";\n    Movement[Movement[\"REORDERED\"] = 4] = \"REORDERED\";\n    Movement[Movement[\"EXITED\"] = 5] = \"EXITED\";\n})(Movement || (Movement = {}));\n\nfunction enteredOrExited(changeType) {\n    return changeType === 1 /* ENTERED */ || changeType === 5 /* EXITED */;\n}\n\nvar NodeChange = function () {\n    function NodeChange(node) {\n        var childList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var characterData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        var oldParentNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        var added = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n        var attributeOldValues = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n        var characterDataOldValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n\n        _classCallCheck(this, NodeChange);\n\n        this.node = node;\n        this.childList = childList;\n        this.attributes = attributes;\n        this.characterData = characterData;\n        this.oldParentNode = oldParentNode;\n        this.added = added;\n        this.attributeOldValues = attributeOldValues;\n        this.characterDataOldValue = characterDataOldValue;\n        this.isCaseInsensitive = this.node.nodeType === Node.ELEMENT_NODE && this.node instanceof HTMLElement && this.node.ownerDocument instanceof HTMLDocument;\n    }\n\n    _createClass(NodeChange, [{\n        key: 'getAttributeOldValue',\n        value: function getAttributeOldValue(name) {\n            if (!this.attributeOldValues) return undefined;\n            if (this.isCaseInsensitive) name = name.toLowerCase();\n            return this.attributeOldValues[name];\n        }\n    }, {\n        key: 'getAttributeNamesMutated',\n        value: function getAttributeNamesMutated() {\n            var names = [];\n            if (!this.attributeOldValues) return names;\n            for (var name in this.attributeOldValues) {\n                names.push(name);\n            }\n            return names;\n        }\n    }, {\n        key: 'attributeMutated',\n        value: function attributeMutated(name, oldValue) {\n            this.attributes = true;\n            this.attributeOldValues = this.attributeOldValues || {};\n\n            if (name in this.attributeOldValues) return;\n\n            this.attributeOldValues[name] = oldValue;\n        }\n    }, {\n        key: 'characterDataMutated',\n        value: function characterDataMutated(oldValue) {\n            if (this.characterData) return;\n            this.characterData = true;\n            this.characterDataOldValue = oldValue;\n        }\n\n        // Note: is it possible to receive a removal followed by a removal. This\n        // can occur if the removed node is added to an non-observed node, that\n        // node is added to the observed area, and then the node removed from\n        // it.\n\n    }, {\n        key: 'removedFromParent',\n        value: function removedFromParent(parent) {\n            this.childList = true;\n            if (this.added || this.oldParentNode) this.added = false;else this.oldParentNode = parent;\n        }\n    }, {\n        key: 'insertedIntoParent',\n        value: function insertedIntoParent() {\n            this.childList = true;\n            this.added = true;\n        }\n\n        // An node's oldParent is\n        //   -its present parent, if its parentNode was not changed.\n        //   -null if the first thing that happened to it was an add.\n        //   -the node it was removed from if the first thing that happened to it\n        //      was a remove.\n\n    }, {\n        key: 'getOldParent',\n        value: function getOldParent() {\n            if (this.childList) {\n                if (this.oldParentNode) return this.oldParentNode;\n                if (this.added) return null;\n            }\n\n            return this.node.parentNode;\n        }\n    }]);\n\n    return NodeChange;\n}();\n\nfunction ChildListChange() {\n    this.added = new NodeMap();\n    this.removed = new NodeMap();\n    this.maybeMoved = new NodeMap();\n    this.oldPrevious = new NodeMap();\n    this.moved = undefined;\n}\n\nvar TreeChanges = function (_NodeMap) {\n    _inherits(TreeChanges, _NodeMap);\n\n    function TreeChanges(rootNode, mutations) {\n        _classCallCheck(this, TreeChanges);\n\n        var _this2 = _possibleConstructorReturn(this, (TreeChanges.__proto__ || Object.getPrototypeOf(TreeChanges)).call(this));\n\n        _this2.rootNode = rootNode;\n        _this2.reachableCache = undefined;\n        _this2.wasReachableCache = undefined;\n        _this2.anyParentsChanged = false;\n        _this2.anyAttributesChanged = false;\n        _this2.anyCharacterDataChanged = false;\n\n        for (var m = 0; m < mutations.length; m++) {\n            var mutation = mutations[m];\n            switch (mutation.type) {\n\n                case 'childList':\n                    _this2.anyParentsChanged = true;\n                    for (var i = 0; i < mutation.removedNodes.length; i++) {\n                        var node = mutation.removedNodes[i];\n                        _this2.getChange(node).removedFromParent(mutation.target);\n                    }\n                    for (var i = 0; i < mutation.addedNodes.length; i++) {\n                        var node = mutation.addedNodes[i];\n                        _this2.getChange(node).insertedIntoParent();\n                    }\n                    break;\n\n                case 'attributes':\n                    _this2.anyAttributesChanged = true;\n                    var change = _this2.getChange(mutation.target);\n                    change.attributeMutated(mutation.attributeName, mutation.oldValue);\n                    break;\n\n                case 'characterData':\n                    _this2.anyCharacterDataChanged = true;\n                    var change = _this2.getChange(mutation.target);\n                    change.characterDataMutated(mutation.oldValue);\n                    break;\n            }\n        }\n        return _this2;\n    }\n\n    _createClass(TreeChanges, [{\n        key: 'getChange',\n        value: function getChange(node) {\n            var change = this.get(node);\n            if (!change) {\n                change = new NodeChange(node);\n                this.set(node, change);\n            }\n            return change;\n        }\n    }, {\n        key: 'getOldParent',\n        value: function getOldParent(node) {\n            var change = this.get(node);\n            return change ? change.getOldParent() : node.parentNode;\n        }\n    }, {\n        key: 'getIsReachable',\n        value: function getIsReachable(node) {\n            if (node === this.rootNode) return true;\n            if (!node) return false;\n\n            this.reachableCache = this.reachableCache || new NodeMap();\n            var isReachable = this.reachableCache.get(node);\n            if (isReachable === undefined) {\n                isReachable = this.getIsReachable(node.parentNode);\n                this.reachableCache.set(node, isReachable);\n            }\n            return isReachable;\n        }\n\n        // A node wasReachable if its oldParent wasReachable.\n\n    }, {\n        key: 'getWasReachable',\n        value: function getWasReachable(node) {\n            if (node === this.rootNode) return true;\n            if (!node) return false;\n\n            this.wasReachableCache = this.wasReachableCache || new NodeMap();\n            var wasReachable = this.wasReachableCache.get(node);\n            if (wasReachable === undefined) {\n                wasReachable = this.getWasReachable(this.getOldParent(node));\n                this.wasReachableCache.set(node, wasReachable);\n            }\n            return wasReachable;\n        }\n    }, {\n        key: 'reachabilityChange',\n        value: function reachabilityChange(node) {\n            if (this.getIsReachable(node)) {\n                return this.getWasReachable(node) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;\n            }\n\n            return this.getWasReachable(node) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;\n        }\n    }]);\n\n    return TreeChanges;\n}(NodeMap);\n\nfunction MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {\n    this.rootNode = rootNode;\n    this.mutations = mutations;\n    this.selectors = selectors;\n    this.calcReordered = calcReordered;\n    this.calcOldPreviousSibling = calcOldPreviousSibling;\n    this.treeChanges = new TreeChanges(rootNode, mutations);\n    this.entered = [];\n    this.exited = [];\n    this.stayedIn = new NodeMap();\n    this.visited = new NodeMap();\n    this.childListChangeMap = undefined;\n    this.characterDataOnly = undefined;\n    this.matchCache = undefined;\n\n    this.processMutations();\n}\n\nMutationProjection.prototype.processMutations = function () {\n    if (!this.treeChanges.anyParentsChanged && !this.treeChanges.anyAttributesChanged) return;\n\n    var changedNodes = this.treeChanges.keys();\n    for (var i = 0; i < changedNodes.length; i++) {\n        this.visitNode(changedNodes[i], undefined);\n    }\n};\n\nMutationProjection.prototype.visitNode = function (node, parentReachable) {\n    if (this.visited.has(node)) return;\n\n    this.visited.set(node, true);\n\n    var change = this.treeChanges.get(node);\n    var reachable = parentReachable;\n\n    // node inherits its parent's reachability change unless\n    // its parentNode was mutated.\n    if (change && change.childList || reachable == undefined) reachable = this.treeChanges.reachabilityChange(node);\n\n    if (reachable === 0 /* STAYED_OUT */) return;\n\n    // Cache match results for sub-patterns.\n    this.matchabilityChange(node);\n\n    if (reachable === 1 /* ENTERED */) {\n            this.entered.push(node);\n        } else if (reachable === 5 /* EXITED */) {\n            this.exited.push(node);\n            this.ensureHasOldPreviousSiblingIfNeeded(node);\n        } else if (reachable === 2 /* STAYED_IN */) {\n            var movement = 2 /* STAYED_IN */;\n\n            if (change && change.childList) {\n                if (change.oldParentNode !== node.parentNode) {\n                    movement = 3 /* REPARENTED */;\n                    this.ensureHasOldPreviousSiblingIfNeeded(node);\n                } else if (this.calcReordered && this.wasReordered(node)) {\n                    movement = 4 /* REORDERED */;\n                }\n            }\n\n            this.stayedIn.set(node, movement);\n        }\n\n    if (reachable === 2 /* STAYED_IN */) return;\n\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n        this.visitNode(child, reachable);\n    }\n};\n\nMutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {\n    if (!this.calcOldPreviousSibling) return;\n\n    this.processChildlistChanges();\n\n    var parentNode = node.parentNode;\n    var nodeChange = this.treeChanges.get(node);\n    if (nodeChange && nodeChange.oldParentNode) parentNode = nodeChange.oldParentNode;\n\n    var change = this.childListChangeMap.get(parentNode);\n    if (!change) {\n        change = new ChildListChange();\n        this.childListChangeMap.set(parentNode, change);\n    }\n\n    if (!change.oldPrevious.has(node)) {\n        change.oldPrevious.set(node, node.previousSibling);\n    }\n};\n\nMutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {\n    this.selectors = selectors;\n    this.characterDataOnly = characterDataOnly;\n\n    for (var i = 0; i < this.entered.length; i++) {\n        var node = this.entered[i];\n        var matchable = this.matchabilityChange(node);\n        if (matchable === 1 /* ENTERED */ || matchable === 2 /* STAYED_IN */) summary.added.push(node);\n    }\n\n    var stayedInNodes = this.stayedIn.keys();\n    for (var i = 0; i < stayedInNodes.length; i++) {\n        var node = stayedInNodes[i];\n        var matchable = this.matchabilityChange(node);\n\n        if (matchable === 1 /* ENTERED */) {\n                summary.added.push(node);\n            } else if (matchable === 5 /* EXITED */) {\n                summary.removed.push(node);\n            } else if (matchable === 2 /* STAYED_IN */ && (summary.reparented || summary.reordered)) {\n            var movement = this.stayedIn.get(node);\n            if (summary.reparented && movement === 3 /* REPARENTED */) summary.reparented.push(node);else if (summary.reordered && movement === 4 /* REORDERED */) summary.reordered.push(node);\n        }\n    }\n\n    for (var i = 0; i < this.exited.length; i++) {\n        var node = this.exited[i];\n        var matchable = this.matchabilityChange(node);\n        if (matchable === 5 /* EXITED */ || matchable === 2 /* STAYED_IN */) summary.removed.push(node);\n    }\n};\n\nMutationProjection.prototype.getOldParentNode = function (node) {\n    var change = this.treeChanges.get(node);\n    if (change && change.childList) return change.oldParentNode ? change.oldParentNode : null;\n\n    var reachabilityChange = this.treeChanges.reachabilityChange(node);\n    if (reachabilityChange === 0 /* STAYED_OUT */ || reachabilityChange === 1 /* ENTERED */) throw Error('getOldParentNode requested on invalid node.');\n\n    return node.parentNode;\n};\n\nMutationProjection.prototype.getOldPreviousSibling = function (node) {\n    var parentNode = node.parentNode;\n    var nodeChange = this.treeChanges.get(node);\n    if (nodeChange && nodeChange.oldParentNode) parentNode = nodeChange.oldParentNode;\n\n    var change = this.childListChangeMap.get(parentNode);\n    if (!change) throw Error('getOldPreviousSibling requested on invalid node.');\n\n    return change.oldPrevious.get(node);\n};\n\nMutationProjection.prototype.getOldAttribute = function (element, attrName) {\n    var change = this.treeChanges.get(element);\n    if (!change || !change.attributes) throw Error('getOldAttribute requested on invalid node.');\n\n    var value = change.getAttributeOldValue(attrName);\n    if (value === undefined) throw Error('getOldAttribute requested for unchanged attribute name.');\n\n    return value;\n};\n\nMutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {\n    if (!this.treeChanges.anyAttributesChanged) return {};\n\n    var attributeFilter;\n    var caseInsensitiveFilter;\n    if (includeAttributes) {\n        attributeFilter = {};\n        caseInsensitiveFilter = {};\n        for (var i = 0; i < includeAttributes.length; i++) {\n            var attrName = includeAttributes[i];\n            attributeFilter[attrName] = true;\n            caseInsensitiveFilter[attrName.toLowerCase()] = attrName;\n        }\n    }\n\n    var result = {};\n    var nodes = this.treeChanges.keys();\n\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        var change = this.treeChanges.get(node);\n        if (!change.attributes) continue;\n\n        if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(node) || 2 /* STAYED_IN */ !== this.matchabilityChange(node)) {\n            continue;\n        }\n\n        var element = node;\n        var changedAttrNames = change.getAttributeNamesMutated();\n        for (var j = 0; j < changedAttrNames.length; j++) {\n            var attrName = changedAttrNames[j];\n\n            if (attributeFilter && !attributeFilter[attrName] && !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {\n                continue;\n            }\n\n            var oldValue = change.getAttributeOldValue(attrName);\n            if (oldValue === element.getAttribute(attrName)) continue;\n\n            if (caseInsensitiveFilter && change.isCaseInsensitive) attrName = caseInsensitiveFilter[attrName];\n\n            result[attrName] = result[attrName] || [];\n            result[attrName].push(element);\n        }\n    }\n\n    return result;\n};\n\nMutationProjection.prototype.getOldCharacterData = function (node) {\n    var change = this.treeChanges.get(node);\n    if (!change || !change.characterData) throw Error('getOldCharacterData requested on invalid node.');\n\n    return change.characterDataOldValue;\n};\n\nMutationProjection.prototype.getCharacterDataChanged = function () {\n    if (!this.treeChanges.anyCharacterDataChanged) return [];\n\n    var nodes = this.treeChanges.keys();\n    var result = [];\n    for (var i = 0; i < nodes.length; i++) {\n        var target = nodes[i];\n        if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(target)) continue;\n\n        var change = this.treeChanges.get(target);\n        if (!change.characterData || target.textContent == change.characterDataOldValue) continue;\n\n        result.push(target);\n    }\n\n    return result;\n};\n\nMutationProjection.prototype.computeMatchabilityChange = function (selector, el) {\n    if (!this.matchCache) this.matchCache = [];\n    if (!this.matchCache[selector.uid]) this.matchCache[selector.uid] = new NodeMap();\n\n    var cache = this.matchCache[selector.uid];\n    var result = cache.get(el);\n    if (result === undefined) {\n        result = selector.matchabilityChange(el, this.treeChanges.get(el));\n        cache.set(el, result);\n    }\n    return result;\n};\n\nMutationProjection.prototype.matchabilityChange = function (node) {\n    var _this = this;\n    // TODO(rafaelw): Include PI, CDATA?\n    // Only include text nodes.\n    if (this.characterDataOnly) {\n        switch (node.nodeType) {\n            case Node.COMMENT_NODE:\n            case Node.TEXT_NODE:\n                return 2 /* STAYED_IN */;\n            default:\n                return 0 /* STAYED_OUT */;\n        }\n    }\n\n    // No element filter. Include all nodes.\n    if (!this.selectors) return 2 /* STAYED_IN */;\n\n    // Element filter. Exclude non-elements.\n    if (node.nodeType !== Node.ELEMENT_NODE) return 0 /* STAYED_OUT */;\n\n    var el = node;\n\n    var matchChanges = this.selectors.map(function (selector) {\n        return _this.computeMatchabilityChange(selector, el);\n    });\n\n    var accum = 0 /* STAYED_OUT */;\n    var i = 0;\n\n    while (accum !== 2 /* STAYED_IN */ && i < matchChanges.length) {\n        switch (matchChanges[i]) {\n            case 2 /* STAYED_IN */:\n                accum = 2 /* STAYED_IN */;\n                break;\n            case 1 /* ENTERED */:\n                if (accum === 5 /* EXITED */) accum = 2 /* STAYED_IN */;else accum = 1 /* ENTERED */;\n                break;\n            case 5 /* EXITED */:\n                if (accum === 1 /* ENTERED */) accum = 2 /* STAYED_IN */;else accum = 5 /* EXITED */;\n                break;\n        }\n\n        i++;\n    }\n\n    return accum;\n};\n\nMutationProjection.prototype.getChildlistChange = function (el) {\n    var change = this.childListChangeMap.get(el);\n    if (!change) {\n        change = new ChildListChange();\n        this.childListChangeMap.set(el, change);\n    }\n\n    return change;\n};\n\nMutationProjection.prototype.processChildlistChanges = function () {\n    var _this3 = this;\n\n    if (this.childListChangeMap) return;\n\n    this.childListChangeMap = new NodeMap();\n\n    var _loop = function _loop() {\n        mutation = _this3.mutations[i];\n\n        if (mutation.type != 'childList') return 'continue';\n\n        if (_this3.treeChanges.reachabilityChange(mutation.target) !== 2 /* STAYED_IN */ && !_this3.calcOldPreviousSibling) return 'continue';\n\n        change = _this3.getChildlistChange(mutation.target);\n        oldPrevious = mutation.previousSibling;\n\n\n        function recordOldPrevious(node, previous) {\n            if (!node || change.oldPrevious.has(node) || change.added.has(node) || change.maybeMoved.has(node)) return;\n\n            if (previous && (change.added.has(previous) || change.maybeMoved.has(previous))) return;\n\n            change.oldPrevious.set(node, previous);\n        }\n\n        for (j = 0; j < mutation.removedNodes.length; j++) {\n            node = mutation.removedNodes[j];\n\n            recordOldPrevious(node, oldPrevious);\n\n            if (change.added.has(node)) {\n                change.added.delete(node);\n            } else {\n                change.removed.set(node, true);\n                change.maybeMoved.delete(node);\n            }\n\n            oldPrevious = node;\n        }\n\n        recordOldPrevious(mutation.nextSibling, oldPrevious);\n\n        for (j = 0; j < mutation.addedNodes.length; j++) {\n            node = mutation.addedNodes[j];\n\n            if (change.removed.has(node)) {\n                change.removed.delete(node);\n                change.maybeMoved.set(node, true);\n            } else {\n                change.added.set(node, true);\n            }\n        }\n    };\n\n    for (var i = 0; i < this.mutations.length; i++) {\n        var mutation;\n        var change;\n        var oldPrevious;\n        var j;\n        var node;\n        var j;\n        var node;\n\n        var _ret = _loop();\n\n        if (_ret === 'continue') continue;\n    }\n};\n\nMutationProjection.prototype.wasReordered = function (node) {\n    if (!this.treeChanges.anyParentsChanged) return false;\n\n    this.processChildlistChanges();\n\n    var parentNode = node.parentNode;\n    var nodeChange = this.treeChanges.get(node);\n    if (nodeChange && nodeChange.oldParentNode) parentNode = nodeChange.oldParentNode;\n\n    var change = this.childListChangeMap.get(parentNode);\n    if (!change) return false;\n\n    if (change.moved) return change.moved.get(node);\n\n    change.moved = new NodeMap();\n    var pendingMoveDecision = new NodeMap();\n\n    function isMoved(node) {\n        if (!node) return false;\n        if (!change.maybeMoved.has(node)) return false;\n\n        var didMove = change.moved.get(node);\n        if (didMove !== undefined) return didMove;\n\n        if (pendingMoveDecision.has(node)) {\n            didMove = true;\n        } else {\n            pendingMoveDecision.set(node, true);\n            didMove = getPrevious(node) !== getOldPrevious(node);\n        }\n\n        if (pendingMoveDecision.has(node)) {\n            pendingMoveDecision.delete(node);\n            change.moved.set(node, didMove);\n        } else {\n            didMove = change.moved.get(node);\n        }\n\n        return didMove;\n    }\n\n    var oldPreviousCache = new NodeMap();\n    function getOldPrevious(node) {\n        var oldPrevious = oldPreviousCache.get(node);\n        if (oldPrevious !== undefined) return oldPrevious;\n\n        oldPrevious = change.oldPrevious.get(node);\n        while (oldPrevious && (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {\n            oldPrevious = getOldPrevious(oldPrevious);\n        }\n\n        if (oldPrevious === undefined) oldPrevious = node.previousSibling;\n        oldPreviousCache.set(node, oldPrevious);\n\n        return oldPrevious;\n    }\n\n    var previousCache = new NodeMap();\n    function getPrevious(node) {\n        if (previousCache.has(node)) return previousCache.get(node);\n\n        var previous = node.previousSibling;\n        while (previous && (change.added.has(previous) || isMoved(previous))) {\n            previous = previous.previousSibling;\n        }previousCache.set(node, previous);\n        return previous;\n    }\n\n    change.maybeMoved.keys().forEach(isMoved);\n    return change.moved.get(node);\n};\n\nfunction Summary(projection, query) {\n    var _this = this;\n    this.projection = projection;\n    this.added = [];\n    this.removed = [];\n    this.reparented = query.all || query.element ? [] : undefined;\n    this.reordered = query.all ? [] : undefined;\n\n    projection.getChanged(this, query.elementFilter, query.characterData);\n\n    if (query.all || query.attribute || query.attributeList) {\n        var filter = query.attribute ? [query.attribute] : query.attributeList;\n        var attributeChanged = projection.attributeChangedNodes(filter);\n\n        if (query.attribute) {\n            this.valueChanged = attributeChanged[query.attribute] || [];\n        } else {\n            this.attributeChanged = attributeChanged;\n            if (query.attributeList) {\n                query.attributeList.forEach(function (attrName) {\n                    if (!_this.attributeChanged.hasOwnProperty(attrName)) _this.attributeChanged[attrName] = [];\n                });\n            }\n        }\n    }\n\n    if (query.all || query.characterData) {\n        var characterDataChanged = projection.getCharacterDataChanged();\n\n        if (query.characterData) this.valueChanged = characterDataChanged;else this.characterDataChanged = characterDataChanged;\n    }\n\n    if (this.reordered) this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);\n}\n\nSummary.prototype.getOldParentNode = function (node) {\n    return this.projection.getOldParentNode(node);\n};\n\nSummary.prototype.getOldAttribute = function (node, name) {\n    return this.projection.getOldAttribute(node, name);\n};\n\nSummary.prototype.getOldCharacterData = function (node) {\n    return this.projection.getOldCharacterData(node);\n};\n\nSummary.prototype.getOldPreviousSibling = function (node) {\n    return this.projection.getOldPreviousSibling(node);\n};\n\n// TODO (rafaelw): Allow ':' and '.' as valid name characters.\nvar validNameInitialChar = /[a-zA-Z_]+/;\nvar validNameNonInitialChar = /[a-zA-Z0-9_\\-]+/;\n\n// TODO: Consider allowing backslash in the attrValue.\n// TODO: There's got a to be way to represent this state machine\n// more compactly???\nfunction escapeQuotes(value) {\n    return '\"' + value.replace(/\"/, '\\\\\\\"') + '\"';\n}\n\nfunction Qualifier() {}\n\nQualifier.prototype.matches = function (oldValue) {\n    if (oldValue === null) return false;\n\n    if (this.attrValue === undefined) return true;\n\n    if (!this.contains) return this.attrValue == oldValue;\n\n    var tokens = oldValue.split(' ');\n    for (var i = 0; i < tokens.length; i++) {\n        if (this.attrValue === tokens[i]) return true;\n    }\n\n    return false;\n};\n\nQualifier.prototype.toString = function () {\n    if (this.attrName === 'class' && this.contains) return '.' + this.attrValue;\n\n    if (this.attrName === 'id' && !this.contains) return '#' + this.attrValue;\n\n    if (this.contains) return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';\n\n    if ('attrValue' in this) return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';\n\n    return '[' + this.attrName + ']';\n};\n\nfunction Selector() {\n    this.nextUid = 1;\n    this.uid = this.nextUid++;\n    this.qualifiers = [];\n}\n\nObject.defineProperty(Selector.prototype, \"caseInsensitiveTagName\", {\n    get: function get() {\n        return this.tagName.toUpperCase();\n    },\n    enumerable: true,\n    configurable: true\n});\n\nObject.defineProperty(Selector.prototype, \"selectorString\", {\n    get: function get() {\n        return this.tagName + this.qualifiers.join('');\n    },\n    enumerable: true,\n    configurable: true\n});\n\nSelector.prototype.isMatching = function (el) {\n    return el[this.matchesSelector](this.selectorString);\n};\n\nSelector.prototype.wasMatching = function (el, change, isMatching) {\n    if (!change || !change.attributes) return isMatching;\n\n    var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;\n    if (tagName !== '*' && tagName !== el.tagName) return false;\n\n    var attributeOldValues = [];\n    var anyChanged = false;\n    for (var i = 0; i < this.qualifiers.length; i++) {\n        var qualifier = this.qualifiers[i];\n        var oldValue = change.getAttributeOldValue(qualifier.attrName);\n        attributeOldValues.push(oldValue);\n        anyChanged = anyChanged || oldValue !== undefined;\n    }\n\n    if (!anyChanged) return isMatching;\n\n    for (var i = 0; i < this.qualifiers.length; i++) {\n        var qualifier = this.qualifiers[i];\n        var oldValue = attributeOldValues[i];\n        if (oldValue === undefined) oldValue = el.getAttribute(qualifier.attrName);\n        if (!qualifier.matches(oldValue)) return false;\n    }\n\n    return true;\n};\n\nSelector.prototype.matchabilityChange = function (el, change) {\n    var isMatching = this.isMatching(el);\n    if (isMatching) return this.wasMatching(el, change, isMatching) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;else return this.wasMatching(el, change, isMatching) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;\n};\n\nSelector.parseSelectors = function (input) {\n    var selectors = [];\n    var currentSelector;\n    var currentQualifier;\n\n    function newSelector() {\n        if (currentSelector) {\n            if (currentQualifier) {\n                currentSelector.qualifiers.push(currentQualifier);\n                currentQualifier = undefined;\n            }\n\n            selectors.push(currentSelector);\n        }\n        currentSelector = new Selector();\n    }\n\n    function newQualifier() {\n        if (currentQualifier) currentSelector.qualifiers.push(currentQualifier);\n\n        currentQualifier = new Qualifier();\n    }\n\n    var WHITESPACE = /\\s/;\n    var valueQuoteChar;\n    var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';\n\n    var SELECTOR = 1;\n    var TAG_NAME = 2;\n    var QUALIFIER = 3;\n    var QUALIFIER_NAME_FIRST_CHAR = 4;\n    var QUALIFIER_NAME = 5;\n    var ATTR_NAME_FIRST_CHAR = 6;\n    var ATTR_NAME = 7;\n    var EQUIV_OR_ATTR_QUAL_END = 8;\n    var EQUAL = 9;\n    var ATTR_QUAL_END = 10;\n    var VALUE_FIRST_CHAR = 11;\n    var VALUE = 12;\n    var QUOTED_VALUE = 13;\n    var SELECTOR_SEPARATOR = 14;\n\n    var state = SELECTOR;\n    var i = 0;\n    while (i < input.length) {\n        var c = input[i++];\n\n        switch (state) {\n            case SELECTOR:\n                if (c.match(validNameInitialChar)) {\n                    newSelector();\n                    currentSelector.tagName = c;\n                    state = TAG_NAME;\n                    break;\n                }\n\n                if (c == '*') {\n                    newSelector();\n                    currentSelector.tagName = '*';\n                    state = QUALIFIER;\n                    break;\n                }\n\n                if (c == '.') {\n                    newSelector();\n                    newQualifier();\n                    currentSelector.tagName = '*';\n                    currentQualifier.attrName = 'class';\n                    currentQualifier.contains = true;\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '#') {\n                    newSelector();\n                    newQualifier();\n                    currentSelector.tagName = '*';\n                    currentQualifier.attrName = 'id';\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '[') {\n                    newSelector();\n                    newQualifier();\n                    currentSelector.tagName = '*';\n                    currentQualifier.attrName = '';\n                    state = ATTR_NAME_FIRST_CHAR;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) break;\n\n                throw Error(SYNTAX_ERROR);\n\n            case TAG_NAME:\n                if (c.match(validNameNonInitialChar)) {\n                    currentSelector.tagName += c;\n                    break;\n                }\n\n                if (c == '.') {\n                    newQualifier();\n                    currentQualifier.attrName = 'class';\n                    currentQualifier.contains = true;\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '#') {\n                    newQualifier();\n                    currentQualifier.attrName = 'id';\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '[') {\n                    newQualifier();\n                    currentQualifier.attrName = '';\n                    state = ATTR_NAME_FIRST_CHAR;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) {\n                    state = SELECTOR_SEPARATOR;\n                    break;\n                }\n\n                if (c == ',') {\n                    state = SELECTOR;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n\n            case QUALIFIER:\n                if (c == '.') {\n                    newQualifier();\n                    currentQualifier.attrName = 'class';\n                    currentQualifier.contains = true;\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '#') {\n                    newQualifier();\n                    currentQualifier.attrName = 'id';\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '[') {\n                    newQualifier();\n                    currentQualifier.attrName = '';\n                    state = ATTR_NAME_FIRST_CHAR;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) {\n                    state = SELECTOR_SEPARATOR;\n                    break;\n                }\n\n                if (c == ',') {\n                    state = SELECTOR;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n\n            case QUALIFIER_NAME_FIRST_CHAR:\n                if (c.match(validNameInitialChar)) {\n                    currentQualifier.attrValue = c;\n                    state = QUALIFIER_NAME;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n\n            case QUALIFIER_NAME:\n                if (c.match(validNameNonInitialChar)) {\n                    currentQualifier.attrValue += c;\n                    break;\n                }\n\n                if (c == '.') {\n                    newQualifier();\n                    currentQualifier.attrName = 'class';\n                    currentQualifier.contains = true;\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '#') {\n                    newQualifier();\n                    currentQualifier.attrName = 'id';\n                    state = QUALIFIER_NAME_FIRST_CHAR;\n                    break;\n                }\n                if (c == '[') {\n                    newQualifier();\n                    state = ATTR_NAME_FIRST_CHAR;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) {\n                    state = SELECTOR_SEPARATOR;\n                    break;\n                }\n                if (c == ',') {\n                    state = SELECTOR;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n\n            case ATTR_NAME_FIRST_CHAR:\n                if (c.match(validNameInitialChar)) {\n                    currentQualifier.attrName = c;\n                    state = ATTR_NAME;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) break;\n\n                throw Error(SYNTAX_ERROR);\n\n            case ATTR_NAME:\n                if (c.match(validNameNonInitialChar)) {\n                    currentQualifier.attrName += c;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) {\n                    state = EQUIV_OR_ATTR_QUAL_END;\n                    break;\n                }\n\n                if (c == '~') {\n                    currentQualifier.contains = true;\n                    state = EQUAL;\n                    break;\n                }\n\n                if (c == '=') {\n                    currentQualifier.attrValue = '';\n                    state = VALUE_FIRST_CHAR;\n                    break;\n                }\n\n                if (c == ']') {\n                    state = QUALIFIER;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n\n            case EQUIV_OR_ATTR_QUAL_END:\n                if (c == '~') {\n                    currentQualifier.contains = true;\n                    state = EQUAL;\n                    break;\n                }\n\n                if (c == '=') {\n                    currentQualifier.attrValue = '';\n                    state = VALUE_FIRST_CHAR;\n                    break;\n                }\n\n                if (c == ']') {\n                    state = QUALIFIER;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) break;\n\n                throw Error(SYNTAX_ERROR);\n\n            case EQUAL:\n                if (c == '=') {\n                    currentQualifier.attrValue = '';\n                    state = VALUE_FIRST_CHAR;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n\n            case ATTR_QUAL_END:\n                if (c == ']') {\n                    state = QUALIFIER;\n                    break;\n                }\n\n                if (c.match(WHITESPACE)) break;\n\n                throw Error(SYNTAX_ERROR);\n\n            case VALUE_FIRST_CHAR:\n                if (c.match(WHITESPACE)) break;\n\n                if (c == '\"' || c == \"'\") {\n                    valueQuoteChar = c;\n                    state = QUOTED_VALUE;\n                    break;\n                }\n\n                currentQualifier.attrValue += c;\n                state = VALUE;\n                break;\n\n            case VALUE:\n                if (c.match(WHITESPACE)) {\n                    state = ATTR_QUAL_END;\n                    break;\n                }\n                if (c == ']') {\n                    state = QUALIFIER;\n                    break;\n                }\n                if (c == \"'\" || c == '\"') throw Error(SYNTAX_ERROR);\n\n                currentQualifier.attrValue += c;\n                break;\n\n            case QUOTED_VALUE:\n                if (c == valueQuoteChar) {\n                    state = ATTR_QUAL_END;\n                    break;\n                }\n\n                currentQualifier.attrValue += c;\n                break;\n\n            case SELECTOR_SEPARATOR:\n                if (c.match(WHITESPACE)) break;\n\n                if (c == ',') {\n                    state = SELECTOR;\n                    break;\n                }\n\n                throw Error(SYNTAX_ERROR);\n        }\n    }\n\n    switch (state) {\n        case SELECTOR:\n        case TAG_NAME:\n        case QUALIFIER:\n        case QUALIFIER_NAME:\n        case SELECTOR_SEPARATOR:\n            // Valid end states.\n            newSelector();\n            break;\n        default:\n            throw Error(SYNTAX_ERROR);\n    }\n\n    if (!selectors.length) throw Error(SYNTAX_ERROR);\n\n    return selectors;\n};\n\nSelector.matchesSelector = function () {\n    var element = document.createElement('div');\n    if (typeof element['webkitMatchesSelector'] === 'function') return 'webkitMatchesSelector';\n    if (typeof element['mozMatchesSelector'] === 'function') return 'mozMatchesSelector';\n    if (typeof element['msMatchesSelector'] === 'function') return 'msMatchesSelector';\n\n    return 'matchesSelector';\n};\n\nvar attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\\-:\\.]*)$/;\n\nfunction validateAttribute(attribute) {\n    if (typeof attribute != 'string') throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    attribute = attribute.trim();\n\n    if (!attribute) throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    if (!attribute.match(attributeFilterPattern)) throw Error('Invalid request option. invalid attribute name: ' + attribute);\n\n    return attribute;\n}\n\nfunction validateElementAttributes(attribs) {\n    if (!attribs.trim().length) throw Error('Invalid request option: elementAttributes must contain at least one attribute.');\n\n    var lowerAttributes = {};\n    var attributes = {};\n\n    var tokens = attribs.split(/\\s+/);\n    for (var i = 0; i < tokens.length; i++) {\n        var name = tokens[i];\n        if (!name) continue;\n\n        var name = validateAttribute(name);\n        var nameLower = name.toLowerCase();\n        if (lowerAttributes[nameLower]) throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');\n\n        attributes[name] = true;\n        lowerAttributes[nameLower] = true;\n    }\n\n    return Object.keys(attributes);\n}\n\nfunction elementFilterAttributes(selectors) {\n    var attributes = {};\n\n    selectors.forEach(function (selector) {\n        selector.qualifiers.forEach(function (qualifier) {\n            attributes[qualifier.attrName] = true;\n        });\n    });\n\n    return Object.keys(attributes);\n}\n\nfunction MutationSummary(opts) {\n    var _this = this;\n\n    this.connected = false;\n    this.options = this.validateOptions(opts);\n    this.observerOptions = this.createObserverOptions(this.options.queries);\n    this.root = this.options.rootNode;\n    this.callback = this.options.callback;\n\n    this.elementFilter = Array.prototype.concat.apply([], this.options.queries.map(function (query) {\n        return query.elementFilter ? query.elementFilter : [];\n    }));\n\n    if (!this.elementFilter.length) this.elementFilter = undefined;\n\n    this.calcReordered = this.options.queries.some(function (query) {\n        return query.all;\n    });\n\n    this.queryValidators = [];\n\n    if (this.createQueryValidator) {\n        this.queryValidators = this.options.queries.map(function (query) {\n            return this.createQueryValidator(_this.root, query);\n        });\n    }\n\n    this.observer = new MutationObserverCtor(function (mutations) {\n        _this.observerCallback(mutations);\n    });\n\n    this.reconnect();\n}\n\nMutationSummary.prototype.createObserverOptions = function (queries) {\n\n    var observerOptions = {\n        childList: true,\n        subtree: true\n    };\n\n    var attributeFilter;\n\n    function observeAttributes(attributes) {\n        if (observerOptions.attributes && !attributeFilter) return;\n\n        observerOptions.attributes = true;\n        observerOptions.attributeOldValue = true;\n\n        if (!attributes) {\n            // observe all.\n            attributeFilter = undefined;\n            return;\n        }\n\n        // add to observed.\n        attributeFilter = attributeFilter || {};\n        attributes.forEach(function (attribute) {\n            attributeFilter[attribute] = true;\n            attributeFilter[attribute.toLowerCase()] = true;\n        });\n    }\n\n    queries.forEach(function (query) {\n        if (query.characterData) {\n            observerOptions.characterData = true;\n            observerOptions.characterDataOldValue = true;\n            return;\n        }\n\n        if (query.all) {\n            observeAttributes();\n            observerOptions.characterData = true;\n            observerOptions.characterDataOldValue = true;\n            return;\n        }\n\n        if (query.attribute) {\n            observeAttributes([query.attribute.trim()]);\n            return;\n        }\n\n        var attributes = elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);\n        if (attributes.length) observeAttributes(attributes);\n    });\n\n    if (attributeFilter) observerOptions.attributeFilter = Object.keys(attributeFilter);\n\n    return observerOptions;\n};\n\nMutationSummary.prototype.validateOptions = function (options) {\n\n    for (var prop in options) {\n        if (!(prop in MutationSummary.optionKeys)) throw Error('Invalid option: ' + prop);\n    }\n\n    if (typeof options.callback !== 'function') throw Error('Invalid options: callback is required and must be a function');\n\n    if (!options.queries || !options.queries.length) throw Error('Invalid options: queries must contain at least one query request object.');\n\n    var opts = {\n        callback: options.callback,\n        rootNode: options.rootNode || document,\n        observeOwnChanges: !!options.observeOwnChanges,\n        oldPreviousSibling: !!options.oldPreviousSibling,\n        queries: []\n    };\n\n    for (var i = 0; i < options.queries.length; i++) {\n        var request = options.queries[i];\n\n        // all\n        if (request.all) {\n            if (Object.keys(request).length > 1) throw Error('Invalid request option. all has no options.');\n\n            opts.queries.push({ all: true });\n            continue;\n        }\n\n        // attribute\n        if ('attribute' in request) {\n            var query = {\n                attribute: validateAttribute(request.attribute)\n            };\n\n            query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');\n\n            if (Object.keys(request).length > 1) throw Error('Invalid request option. attribute has no options.');\n\n            opts.queries.push(query);\n            continue;\n        }\n\n        // element\n        if ('element' in request) {\n            var requestOptionCount = Object.keys(request).length;\n            var query = {\n                element: request.element,\n                elementFilter: Selector.parseSelectors(request.element)\n            };\n\n            if (request.hasOwnProperty('elementAttributes')) {\n                query.attributeList = validateElementAttributes(request.elementAttributes);\n                requestOptionCount--;\n            }\n\n            if (requestOptionCount > 1) throw Error('Invalid request option. element only allows elementAttributes option.');\n\n            opts.queries.push(query);\n            continue;\n        }\n\n        // characterData\n        if (request.characterData) {\n            if (Object.keys(request).length > 1) throw Error('Invalid request option. characterData has no options.');\n\n            opts.queries.push({ characterData: true });\n            continue;\n        }\n\n        throw Error('Invalid request option. Unknown query request.');\n    }\n\n    return opts;\n};\n\nMutationSummary.prototype.createSummaries = function (mutations) {\n    if (!mutations || !mutations.length) return [];\n\n    var projection = new MutationProjection(this.root, mutations, this.elementFilter, this.calcReordered, this.options.oldPreviousSibling);\n\n    var summaries = [];\n    for (var i = 0; i < this.options.queries.length; i++) {\n        summaries.push(new Summary(projection, this.options.queries[i]));\n    }\n\n    return summaries;\n};\n\nMutationSummary.prototype.checkpointQueryValidators = function () {\n    this.queryValidators.forEach(function (validator) {\n        if (validator) validator.recordPreviousState();\n    });\n};\n\nMutationSummary.prototype.runQueryValidators = function (summaries) {\n    this.queryValidators.forEach(function (validator, index) {\n        if (validator) validator.validate(summaries[index]);\n    });\n};\n\nMutationSummary.prototype.changesToReport = function (summaries) {\n    return summaries.some(function (summary) {\n        var summaryProps = ['added', 'removed', 'reordered', 'reparented', 'valueChanged', 'characterDataChanged'];\n        if (summaryProps.some(function (prop) {\n            return summary[prop] && summary[prop].length;\n        })) return true;\n\n        if (summary.attributeChanged) {\n            var attrNames = Object.keys(summary.attributeChanged);\n            var attrsChanged = attrNames.some(function (attrName) {\n                return !!summary.attributeChanged[attrName].length;\n            });\n            if (attrsChanged) return true;\n        }\n        return false;\n    });\n};\n\nMutationSummary.prototype.observerCallback = function (mutations) {\n    if (!this.options.observeOwnChanges) this.observer.disconnect();\n\n    var summaries = this.createSummaries(mutations);\n    this.runQueryValidators(summaries);\n\n    if (this.options.observeOwnChanges) this.checkpointQueryValidators();\n\n    if (this.changesToReport(summaries)) this.callback(summaries);\n\n    // disconnect() may have been called during the callback.\n    if (!this.options.observeOwnChanges && this.connected) {\n        this.checkpointQueryValidators();\n        this.observer.observe(this.root, this.observerOptions);\n    }\n};\n\nMutationSummary.prototype.reconnect = function () {\n    if (this.connected) throw Error('Already connected');\n\n    this.observer.observe(this.root, this.observerOptions);\n    this.connected = true;\n    this.checkpointQueryValidators();\n};\n\nMutationSummary.prototype.takeSummaries = function () {\n    if (!this.connected) throw Error('Not connected');\n\n    var summaries = this.createSummaries(this.observer.takeRecords());\n    return this.changesToReport(summaries) ? summaries : undefined;\n};\n\nMutationSummary.prototype.disconnect = function () {\n    var summaries = this.takeSummaries();\n    this.observer.disconnect();\n    this.connected = false;\n    return summaries;\n};\n\nMutationSummary.NodeMap = NodeMap;\nMutationSummary.parseElementFilter = Selector.parseSelectors;\nMutationSummary.optionKeys = {\n    'callback': true,\n    'queries': true,\n    'rootNode': true,\n    'oldPreviousSibling': true,\n    'observeOwnChanges': true\n};\n\nmodule.exports = {\n    MutationSummary: MutationSummary\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbXV0YXRpb24tc3VtbWFyeS5qcz8zOWFjIiwid2VicGFjazovLy8/ZDQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMSBHb29nbGUgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxudmFyIE11dGF0aW9uT2JzZXJ2ZXJDdG9yO1xuXG50cnkge1xuXHRpZiAodHlwZW9mIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKVxuXHQgIE11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblx0ZWxzZVxuXHQgIE11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gTXV0YXRpb25PYnNlcnZlcjtcbn0gY2F0Y2ggKGUpIHtcblx0TXV0YXRpb25PYnNlcnZlckN0b3IgPSB1bmRlZmluZWQ7XG59XG5cbmNsYXNzIE5vZGVNYXAge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIHRoaXMuSURfUFJPUCA9ICdfX211dGF0aW9uX3N1bW1hcnlfbm9kZV9tYXBfaWRfXyc7XG4gICAgdGhpcy5uZXh0SWRfID0gMTtcbiAgfVxuXG4gIGlzSW5kZXgocykge1xuICAgICAgcmV0dXJuICtzID09PSBzID4+PiAwO1xuICB9XG5cbiAgbm9kZUlkKG5vZGUpIHtcbiAgICAgIHZhciBpZCA9IG5vZGVbdGhpcy5JRF9QUk9QXTtcbiAgICAgIGlmICghaWQpXG4gICAgICAgICAgaWQgPSBub2RlW3RoaXMuSURfUFJPUF0gPSB0aGlzLm5leHRJZF8rKztcbiAgICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgdmFyIGlkID0gdGhpcy5ub2RlSWQobm9kZSk7XG4gICAgICB0aGlzLm5vZGVzW2lkXSA9IG5vZGU7XG4gICAgICB0aGlzLnZhbHVlc1tpZF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGdldChub2RlKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLm5vZGVJZChub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tpZF07XG4gIH1cblxuICBoYXMobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUlkKG5vZGUpIGluIHRoaXMubm9kZXM7XG4gIH1cblxuICBkZWxldGUobm9kZSkge1xuICAgICAgdmFyIGlkID0gdGhpcy5ub2RlSWQobm9kZSk7XG4gICAgICBkZWxldGUgdGhpcy5ub2Rlc1tpZF07XG4gICAgICB0aGlzLnZhbHVlc1tpZF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBrZXlzKCkge1xuICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzSW5kZXgoaWQpKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRoaXMubm9kZXNbaWRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVzO1xuICB9XG59XG5cbnZhciBNb3ZlbWVudDtcbihmdW5jdGlvbiAoTW92ZW1lbnQpIHtcbiAgICBNb3ZlbWVudFtNb3ZlbWVudFtcIlNUQVlFRF9PVVRcIl0gPSAwXSA9IFwiU1RBWUVEX09VVFwiO1xuICAgIE1vdmVtZW50W01vdmVtZW50W1wiRU5URVJFRFwiXSA9IDFdID0gXCJFTlRFUkVEXCI7XG4gICAgTW92ZW1lbnRbTW92ZW1lbnRbXCJTVEFZRURfSU5cIl0gPSAyXSA9IFwiU1RBWUVEX0lOXCI7XG4gICAgTW92ZW1lbnRbTW92ZW1lbnRbXCJSRVBBUkVOVEVEXCJdID0gM10gPSBcIlJFUEFSRU5URURcIjtcbiAgICBNb3ZlbWVudFtNb3ZlbWVudFtcIlJFT1JERVJFRFwiXSA9IDRdID0gXCJSRU9SREVSRURcIjtcbiAgICBNb3ZlbWVudFtNb3ZlbWVudFtcIkVYSVRFRFwiXSA9IDVdID0gXCJFWElURURcIjtcbn0pKE1vdmVtZW50IHx8IChNb3ZlbWVudCA9IHt9KSk7XG5cbmZ1bmN0aW9uIGVudGVyZWRPckV4aXRlZChjaGFuZ2VUeXBlKSB7XG4gICAgcmV0dXJuIGNoYW5nZVR5cGUgPT09IDEgLyogRU5URVJFRCAqLyB8fCBjaGFuZ2VUeXBlID09PSA1IC8qIEVYSVRFRCAqLztcbn1cblxuY2xhc3MgTm9kZUNoYW5nZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBjaGlsZExpc3Q9ZmFsc2UsIGF0dHJpYnV0ZXM9ZmFsc2UsIGNoYXJhY3RlckRhdGE9ZmFsc2UsXG4gICAgICBvbGRQYXJlbnROb2RlPW51bGwsIGFkZGVkPWZhbHNlLCBhdHRyaWJ1dGVPbGRWYWx1ZXM9bnVsbCwgY2hhcmFjdGVyRGF0YU9sZFZhbHVlPW51bGwpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuY2hpbGRMaXN0ID0gY2hpbGRMaXN0O1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5jaGFyYWN0ZXJEYXRhID0gY2hhcmFjdGVyRGF0YTtcbiAgICB0aGlzLm9sZFBhcmVudE5vZGUgPSBvbGRQYXJlbnROb2RlO1xuICAgIHRoaXMuYWRkZWQgPSBhZGRlZDtcbiAgICB0aGlzLmF0dHJpYnV0ZU9sZFZhbHVlcyA9IGF0dHJpYnV0ZU9sZFZhbHVlcztcbiAgICB0aGlzLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSA9IGNoYXJhY3RlckRhdGFPbGRWYWx1ZTtcbiAgICB0aGlzLmlzQ2FzZUluc2Vuc2l0aXZlID0gdGhpcy5ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLm5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0aGlzLm5vZGUub3duZXJEb2N1bWVudCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudDtcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZU9sZFZhbHVlKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVPbGRWYWx1ZXMpXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmlzQ2FzZUluc2Vuc2l0aXZlKVxuICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVPbGRWYWx1ZXNbbmFtZV07XG4gIH1cblxuICBnZXRBdHRyaWJ1dGVOYW1lc011dGF0ZWQoKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVPbGRWYWx1ZXMpXG4gICAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmF0dHJpYnV0ZU9sZFZhbHVlcykge1xuICAgICAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZXM7XG4gIH1cblxuICBhdHRyaWJ1dGVNdXRhdGVkKG5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVPbGRWYWx1ZXMgPSB0aGlzLmF0dHJpYnV0ZU9sZFZhbHVlcyB8fCB7fTtcblxuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVPbGRWYWx1ZXMpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICB0aGlzLmF0dHJpYnV0ZU9sZFZhbHVlc1tuYW1lXSA9IG9sZFZhbHVlO1xuICB9XG5cbiAgY2hhcmFjdGVyRGF0YU11dGF0ZWQob2xkVmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJhY3RlckRhdGEpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5jaGFyYWN0ZXJEYXRhID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlID0gb2xkVmFsdWU7XG4gIH1cblxuICAvLyBOb3RlOiBpcyBpdCBwb3NzaWJsZSB0byByZWNlaXZlIGEgcmVtb3ZhbCBmb2xsb3dlZCBieSBhIHJlbW92YWwuIFRoaXNcbiAgLy8gY2FuIG9jY3VyIGlmIHRoZSByZW1vdmVkIG5vZGUgaXMgYWRkZWQgdG8gYW4gbm9uLW9ic2VydmVkIG5vZGUsIHRoYXRcbiAgLy8gbm9kZSBpcyBhZGRlZCB0byB0aGUgb2JzZXJ2ZWQgYXJlYSwgYW5kIHRoZW4gdGhlIG5vZGUgcmVtb3ZlZCBmcm9tXG4gIC8vIGl0LlxuICByZW1vdmVkRnJvbVBhcmVudChwYXJlbnQpIHtcbiAgICAgIHRoaXMuY2hpbGRMaXN0ID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmFkZGVkIHx8IHRoaXMub2xkUGFyZW50Tm9kZSlcbiAgICAgICAgICB0aGlzLmFkZGVkID0gZmFsc2U7XG4gICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5vbGRQYXJlbnROb2RlID0gcGFyZW50O1xuICB9XG5cbiAgaW5zZXJ0ZWRJbnRvUGFyZW50KCkge1xuICAgICAgdGhpcy5jaGlsZExpc3QgPSB0cnVlO1xuICAgICAgdGhpcy5hZGRlZCA9IHRydWU7XG4gIH1cblxuICAvLyBBbiBub2RlJ3Mgb2xkUGFyZW50IGlzXG4gIC8vICAgLWl0cyBwcmVzZW50IHBhcmVudCwgaWYgaXRzIHBhcmVudE5vZGUgd2FzIG5vdCBjaGFuZ2VkLlxuICAvLyAgIC1udWxsIGlmIHRoZSBmaXJzdCB0aGluZyB0aGF0IGhhcHBlbmVkIHRvIGl0IHdhcyBhbiBhZGQuXG4gIC8vICAgLXRoZSBub2RlIGl0IHdhcyByZW1vdmVkIGZyb20gaWYgdGhlIGZpcnN0IHRoaW5nIHRoYXQgaGFwcGVuZWQgdG8gaXRcbiAgLy8gICAgICB3YXMgYSByZW1vdmUuXG4gIGdldE9sZFBhcmVudCgpIHtcbiAgICBpZiAodGhpcy5jaGlsZExpc3QpIHtcbiAgICAgIGlmICh0aGlzLm9sZFBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybiB0aGlzLm9sZFBhcmVudE5vZGU7XG4gICAgICBpZiAodGhpcy5hZGRlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gQ2hpbGRMaXN0Q2hhbmdlKCkge1xuICB0aGlzLmFkZGVkID0gbmV3IE5vZGVNYXAoKTtcbiAgdGhpcy5yZW1vdmVkID0gbmV3IE5vZGVNYXAoKTtcbiAgdGhpcy5tYXliZU1vdmVkID0gbmV3IE5vZGVNYXAoKTtcbiAgdGhpcy5vbGRQcmV2aW91cyA9IG5ldyBOb2RlTWFwKCk7XG4gIHRoaXMubW92ZWQgPSB1bmRlZmluZWQ7XG59XG5cbmNsYXNzIFRyZWVDaGFuZ2VzIGV4dGVuZHMgTm9kZU1hcCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihyb290Tm9kZSwgbXV0YXRpb25zKcKge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcbiAgICAgIHRoaXMucmVhY2hhYmxlQ2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLndhc1JlYWNoYWJsZUNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5hbnlQYXJlbnRzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hbnlBdHRyaWJ1dGVzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hbnlDaGFyYWN0ZXJEYXRhQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBtID0gMDsgbSA8IG11dGF0aW9ucy5sZW5ndGg7IG0rKykge1xuICAgICAgICB2YXIgbXV0YXRpb24gPSBtdXRhdGlvbnNbbV07XG4gICAgICAgIHN3aXRjaCAobXV0YXRpb24udHlwZSkge1xuXG4gICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgIHRoaXMuYW55UGFyZW50c0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENoYW5nZShub2RlKS5yZW1vdmVkRnJvbVBhcmVudChtdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2hhbmdlKG5vZGUpLmluc2VydGVkSW50b1BhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgIHRoaXMuYW55QXR0cmlidXRlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHRoaXMuZ2V0Q2hhbmdlKG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICBjaGFuZ2UuYXR0cmlidXRlTXV0YXRlZChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lLCBtdXRhdGlvbi5vbGRWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckRhdGEnOlxuICAgICAgICAgICAgdGhpcy5hbnlDaGFyYWN0ZXJEYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gdGhpcy5nZXRDaGFuZ2UobXV0YXRpb24udGFyZ2V0KTtcbiAgICAgICAgICAgIGNoYW5nZS5jaGFyYWN0ZXJEYXRhTXV0YXRlZChtdXRhdGlvbi5vbGRWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZ2V0Q2hhbmdlKG5vZGUpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSB0aGlzLmdldChub2RlKTtcbiAgICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgICAgY2hhbmdlID0gbmV3IE5vZGVDaGFuZ2Uobm9kZSk7XG4gICAgICAgICAgdGhpcy5zZXQobm9kZSwgY2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cblxuICBnZXRPbGRQYXJlbnQobm9kZSkge1xuICAgICAgdmFyIGNoYW5nZSA9IHRoaXMuZ2V0KG5vZGUpO1xuICAgICAgcmV0dXJuIGNoYW5nZSA/IGNoYW5nZS5nZXRPbGRQYXJlbnQoKSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGdldElzUmVhY2hhYmxlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnJvb3ROb2RlKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgdGhpcy5yZWFjaGFibGVDYWNoZSA9IHRoaXMucmVhY2hhYmxlQ2FjaGUgfHwgbmV3IE5vZGVNYXAoKTtcbiAgICAgIHZhciBpc1JlYWNoYWJsZSA9IHRoaXMucmVhY2hhYmxlQ2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKGlzUmVhY2hhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpc1JlYWNoYWJsZSA9IHRoaXMuZ2V0SXNSZWFjaGFibGUobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICB0aGlzLnJlYWNoYWJsZUNhY2hlLnNldChub2RlLCBpc1JlYWNoYWJsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNSZWFjaGFibGU7XG4gIH1cblxuICAvLyBBIG5vZGUgd2FzUmVhY2hhYmxlIGlmIGl0cyBvbGRQYXJlbnQgd2FzUmVhY2hhYmxlLlxuICBnZXRXYXNSZWFjaGFibGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdE5vZGUpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB0aGlzLndhc1JlYWNoYWJsZUNhY2hlID0gdGhpcy53YXNSZWFjaGFibGVDYWNoZSB8fCBuZXcgTm9kZU1hcCgpO1xuICAgICAgdmFyIHdhc1JlYWNoYWJsZSA9IHRoaXMud2FzUmVhY2hhYmxlQ2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHdhc1JlYWNoYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgd2FzUmVhY2hhYmxlID0gdGhpcy5nZXRXYXNSZWFjaGFibGUodGhpcy5nZXRPbGRQYXJlbnQobm9kZSkpO1xuICAgICAgICAgIHRoaXMud2FzUmVhY2hhYmxlQ2FjaGUuc2V0KG5vZGUsIHdhc1JlYWNoYWJsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2FzUmVhY2hhYmxlO1xuICB9XG5cbiAgcmVhY2hhYmlsaXR5Q2hhbmdlKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmdldElzUmVhY2hhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FzUmVhY2hhYmxlKG5vZGUpID8gMiAvKiBTVEFZRURfSU4gKi8gOiAxIC8qIEVOVEVSRUQgKi87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFdhc1JlYWNoYWJsZShub2RlKSA/IDUgLyogRVhJVEVEICovIDogMCAvKiBTVEFZRURfT1VUICovO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gTXV0YXRpb25Qcm9qZWN0aW9uKHJvb3ROb2RlLCBtdXRhdGlvbnMsIHNlbGVjdG9ycywgY2FsY1Jlb3JkZXJlZCwgY2FsY09sZFByZXZpb3VzU2libGluZykge1xuICB0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG4gIHRoaXMubXV0YXRpb25zID0gbXV0YXRpb25zO1xuICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgdGhpcy5jYWxjUmVvcmRlcmVkID0gY2FsY1Jlb3JkZXJlZDtcbiAgdGhpcy5jYWxjT2xkUHJldmlvdXNTaWJsaW5nID0gY2FsY09sZFByZXZpb3VzU2libGluZztcbiAgdGhpcy50cmVlQ2hhbmdlcyA9IG5ldyBUcmVlQ2hhbmdlcyhyb290Tm9kZSwgbXV0YXRpb25zKTtcbiAgdGhpcy5lbnRlcmVkID0gW107XG4gIHRoaXMuZXhpdGVkID0gW107XG4gIHRoaXMuc3RheWVkSW4gPSBuZXcgTm9kZU1hcCgpO1xuICB0aGlzLnZpc2l0ZWQgPSBuZXcgTm9kZU1hcCgpO1xuICB0aGlzLmNoaWxkTGlzdENoYW5nZU1hcCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jaGFyYWN0ZXJEYXRhT25seSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5tYXRjaENhY2hlID0gdW5kZWZpbmVkO1xuXG4gIHRoaXMucHJvY2Vzc011dGF0aW9ucygpO1xufVxuXG5NdXRhdGlvblByb2plY3Rpb24ucHJvdG90eXBlLnByb2Nlc3NNdXRhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnRyZWVDaGFuZ2VzLmFueVBhcmVudHNDaGFuZ2VkICYmICF0aGlzLnRyZWVDaGFuZ2VzLmFueUF0dHJpYnV0ZXNDaGFuZ2VkKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgY2hhbmdlZE5vZGVzID0gdGhpcy50cmVlQ2hhbmdlcy5rZXlzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52aXNpdE5vZGUoY2hhbmdlZE5vZGVzW2ldLCB1bmRlZmluZWQpO1xuICAgIH1cbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudFJlYWNoYWJsZSkge1xuICAgIGlmICh0aGlzLnZpc2l0ZWQuaGFzKG5vZGUpKVxuICAgICAgICByZXR1cm47XG5cbiAgICB0aGlzLnZpc2l0ZWQuc2V0KG5vZGUsIHRydWUpO1xuXG4gICAgdmFyIGNoYW5nZSA9IHRoaXMudHJlZUNoYW5nZXMuZ2V0KG5vZGUpO1xuICAgIHZhciByZWFjaGFibGUgPSBwYXJlbnRSZWFjaGFibGU7XG5cbiAgICAvLyBub2RlIGluaGVyaXRzIGl0cyBwYXJlbnQncyByZWFjaGFiaWxpdHkgY2hhbmdlIHVubGVzc1xuICAgIC8vIGl0cyBwYXJlbnROb2RlIHdhcyBtdXRhdGVkLlxuICAgIGlmICgoY2hhbmdlICYmIGNoYW5nZS5jaGlsZExpc3QpIHx8IHJlYWNoYWJsZSA9PSB1bmRlZmluZWQpXG4gICAgICAgIHJlYWNoYWJsZSA9IHRoaXMudHJlZUNoYW5nZXMucmVhY2hhYmlsaXR5Q2hhbmdlKG5vZGUpO1xuXG4gICAgaWYgKHJlYWNoYWJsZSA9PT0gMCAvKiBTVEFZRURfT1VUICovKVxuICAgICAgICByZXR1cm47XG5cbiAgICAvLyBDYWNoZSBtYXRjaCByZXN1bHRzIGZvciBzdWItcGF0dGVybnMuXG4gICAgdGhpcy5tYXRjaGFiaWxpdHlDaGFuZ2Uobm9kZSk7XG5cbiAgICBpZiAocmVhY2hhYmxlID09PSAxIC8qIEVOVEVSRUQgKi8pIHtcbiAgICAgICAgdGhpcy5lbnRlcmVkLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIGlmIChyZWFjaGFibGUgPT09IDUgLyogRVhJVEVEICovKSB7XG4gICAgICAgIHRoaXMuZXhpdGVkLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuZW5zdXJlSGFzT2xkUHJldmlvdXNTaWJsaW5nSWZOZWVkZWQobm9kZSk7XG4gICAgfSBlbHNlIGlmIChyZWFjaGFibGUgPT09IDIgLyogU1RBWUVEX0lOICovKSB7XG4gICAgICAgIHZhciBtb3ZlbWVudCA9IDIgLyogU1RBWUVEX0lOICovO1xuXG4gICAgICAgIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmNoaWxkTGlzdCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5vbGRQYXJlbnROb2RlICE9PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBtb3ZlbWVudCA9IDMgLyogUkVQQVJFTlRFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUhhc09sZFByZXZpb3VzU2libGluZ0lmTmVlZGVkKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGNSZW9yZGVyZWQgJiYgdGhpcy53YXNSZW9yZGVyZWQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlbWVudCA9IDQgLyogUkVPUkRFUkVEICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF5ZWRJbi5zZXQobm9kZSwgbW92ZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChyZWFjaGFibGUgPT09IDIgLyogU1RBWUVEX0lOICovKVxuICAgICAgICByZXR1cm47XG5cbiAgICBmb3IgKHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy52aXNpdE5vZGUoY2hpbGQsIHJlYWNoYWJsZSk7XG4gICAgfVxufTtcblxuTXV0YXRpb25Qcm9qZWN0aW9uLnByb3RvdHlwZS5lbnN1cmVIYXNPbGRQcmV2aW91c1NpYmxpbmdJZk5lZWRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCF0aGlzLmNhbGNPbGRQcmV2aW91c1NpYmxpbmcpXG4gICAgICAgIHJldHVybjtcblxuICAgIHRoaXMucHJvY2Vzc0NoaWxkbGlzdENoYW5nZXMoKTtcblxuICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIHZhciBub2RlQ2hhbmdlID0gdGhpcy50cmVlQ2hhbmdlcy5nZXQobm9kZSk7XG4gICAgaWYgKG5vZGVDaGFuZ2UgJiYgbm9kZUNoYW5nZS5vbGRQYXJlbnROb2RlKVxuICAgICAgICBwYXJlbnROb2RlID0gbm9kZUNoYW5nZS5vbGRQYXJlbnROb2RlO1xuXG4gICAgdmFyIGNoYW5nZSA9IHRoaXMuY2hpbGRMaXN0Q2hhbmdlTWFwLmdldChwYXJlbnROb2RlKTtcbiAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSBuZXcgQ2hpbGRMaXN0Q2hhbmdlKCk7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlTWFwLnNldChwYXJlbnROb2RlLCBjaGFuZ2UpO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlLm9sZFByZXZpb3VzLmhhcyhub2RlKSkge1xuICAgICAgICBjaGFuZ2Uub2xkUHJldmlvdXMuc2V0KG5vZGUsIG5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59O1xuXG5NdXRhdGlvblByb2plY3Rpb24ucHJvdG90eXBlLmdldENoYW5nZWQgPSBmdW5jdGlvbiAoc3VtbWFyeSwgc2VsZWN0b3JzLCBjaGFyYWN0ZXJEYXRhT25seSkge1xuICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgIHRoaXMuY2hhcmFjdGVyRGF0YU9ubHkgPSBjaGFyYWN0ZXJEYXRhT25seTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5lbnRlcmVkW2ldO1xuICAgICAgICB2YXIgbWF0Y2hhYmxlID0gdGhpcy5tYXRjaGFiaWxpdHlDaGFuZ2Uobm9kZSk7XG4gICAgICAgIGlmIChtYXRjaGFibGUgPT09IDEgLyogRU5URVJFRCAqLyB8fCBtYXRjaGFibGUgPT09IDIgLyogU1RBWUVEX0lOICovKVxuICAgICAgICAgICAgc3VtbWFyeS5hZGRlZC5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciBzdGF5ZWRJbk5vZGVzID0gdGhpcy5zdGF5ZWRJbi5rZXlzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF5ZWRJbk5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RheWVkSW5Ob2Rlc1tpXTtcbiAgICAgICAgdmFyIG1hdGNoYWJsZSA9IHRoaXMubWF0Y2hhYmlsaXR5Q2hhbmdlKG5vZGUpO1xuXG4gICAgICAgIGlmIChtYXRjaGFibGUgPT09IDEgLyogRU5URVJFRCAqLykge1xuICAgICAgICAgICAgc3VtbWFyeS5hZGRlZC5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoYWJsZSA9PT0gNSAvKiBFWElURUQgKi8pIHtcbiAgICAgICAgICAgIHN1bW1hcnkucmVtb3ZlZC5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoYWJsZSA9PT0gMiAvKiBTVEFZRURfSU4gKi8gJiYgKHN1bW1hcnkucmVwYXJlbnRlZCB8fCBzdW1tYXJ5LnJlb3JkZXJlZCkpIHtcbiAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IHRoaXMuc3RheWVkSW4uZ2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKHN1bW1hcnkucmVwYXJlbnRlZCAmJiBtb3ZlbWVudCA9PT0gMyAvKiBSRVBBUkVOVEVEICovKVxuICAgICAgICAgICAgICAgIHN1bW1hcnkucmVwYXJlbnRlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3VtbWFyeS5yZW9yZGVyZWQgJiYgbW92ZW1lbnQgPT09IDQgLyogUkVPUkRFUkVEICovKVxuICAgICAgICAgICAgICAgIHN1bW1hcnkucmVvcmRlcmVkLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXhpdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5leGl0ZWRbaV07XG4gICAgICAgIHZhciBtYXRjaGFibGUgPSB0aGlzLm1hdGNoYWJpbGl0eUNoYW5nZShub2RlKTtcbiAgICAgICAgaWYgKG1hdGNoYWJsZSA9PT0gNSAvKiBFWElURUQgKi8gfHwgbWF0Y2hhYmxlID09PSAyIC8qIFNUQVlFRF9JTiAqLylcbiAgICAgICAgICAgIHN1bW1hcnkucmVtb3ZlZC5wdXNoKG5vZGUpO1xuICAgIH1cbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0T2xkUGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRoaXMudHJlZUNoYW5nZXMuZ2V0KG5vZGUpO1xuICAgIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmNoaWxkTGlzdClcbiAgICAgICAgcmV0dXJuIGNoYW5nZS5vbGRQYXJlbnROb2RlID8gY2hhbmdlLm9sZFBhcmVudE5vZGUgOiBudWxsO1xuXG4gICAgdmFyIHJlYWNoYWJpbGl0eUNoYW5nZSA9IHRoaXMudHJlZUNoYW5nZXMucmVhY2hhYmlsaXR5Q2hhbmdlKG5vZGUpO1xuICAgIGlmIChyZWFjaGFiaWxpdHlDaGFuZ2UgPT09IDAgLyogU1RBWUVEX09VVCAqLyB8fCByZWFjaGFiaWxpdHlDaGFuZ2UgPT09IDEgLyogRU5URVJFRCAqLylcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2dldE9sZFBhcmVudE5vZGUgcmVxdWVzdGVkIG9uIGludmFsaWQgbm9kZS4nKTtcblxuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG59O1xuXG5NdXRhdGlvblByb2plY3Rpb24ucHJvdG90eXBlLmdldE9sZFByZXZpb3VzU2libGluZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIG5vZGVDaGFuZ2UgPSB0aGlzLnRyZWVDaGFuZ2VzLmdldChub2RlKTtcbiAgICBpZiAobm9kZUNoYW5nZSAmJiBub2RlQ2hhbmdlLm9sZFBhcmVudE5vZGUpXG4gICAgICAgIHBhcmVudE5vZGUgPSBub2RlQ2hhbmdlLm9sZFBhcmVudE5vZGU7XG5cbiAgICB2YXIgY2hhbmdlID0gdGhpcy5jaGlsZExpc3RDaGFuZ2VNYXAuZ2V0KHBhcmVudE5vZGUpO1xuICAgIGlmICghY2hhbmdlKVxuICAgICAgICB0aHJvdyBFcnJvcignZ2V0T2xkUHJldmlvdXNTaWJsaW5nIHJlcXVlc3RlZCBvbiBpbnZhbGlkIG5vZGUuJyk7XG5cbiAgICByZXR1cm4gY2hhbmdlLm9sZFByZXZpb3VzLmdldChub2RlKTtcbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0T2xkQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJOYW1lKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRoaXMudHJlZUNoYW5nZXMuZ2V0KGVsZW1lbnQpO1xuICAgIGlmICghY2hhbmdlIHx8ICFjaGFuZ2UuYXR0cmlidXRlcylcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2dldE9sZEF0dHJpYnV0ZSByZXF1ZXN0ZWQgb24gaW52YWxpZCBub2RlLicpO1xuXG4gICAgdmFyIHZhbHVlID0gY2hhbmdlLmdldEF0dHJpYnV0ZU9sZFZhbHVlKGF0dHJOYW1lKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2dldE9sZEF0dHJpYnV0ZSByZXF1ZXN0ZWQgZm9yIHVuY2hhbmdlZCBhdHRyaWJ1dGUgbmFtZS4nKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZE5vZGVzID0gZnVuY3Rpb24gKGluY2x1ZGVBdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCF0aGlzLnRyZWVDaGFuZ2VzLmFueUF0dHJpYnV0ZXNDaGFuZ2VkKVxuICAgICAgICByZXR1cm4ge307XG5cbiAgICB2YXIgYXR0cmlidXRlRmlsdGVyO1xuICAgIHZhciBjYXNlSW5zZW5zaXRpdmVGaWx0ZXI7XG4gICAgaWYgKGluY2x1ZGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlciA9IHt9O1xuICAgICAgICBjYXNlSW5zZW5zaXRpdmVGaWx0ZXIgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlQXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gaW5jbHVkZUF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXJbYXR0ck5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZUZpbHRlclthdHRyTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGF0dHJOYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBub2RlcyA9IHRoaXMudHJlZUNoYW5nZXMua2V5cygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIHZhciBjaGFuZ2UgPSB0aGlzLnRyZWVDaGFuZ2VzLmdldChub2RlKTtcbiAgICAgICAgaWYgKCFjaGFuZ2UuYXR0cmlidXRlcylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICgyIC8qIFNUQVlFRF9JTiAqLyAhPT0gdGhpcy50cmVlQ2hhbmdlcy5yZWFjaGFiaWxpdHlDaGFuZ2Uobm9kZSkgfHwgMiAvKiBTVEFZRURfSU4gKi8gIT09IHRoaXMubWF0Y2hhYmlsaXR5Q2hhbmdlKG5vZGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgdmFyIGNoYW5nZWRBdHRyTmFtZXMgPSBjaGFuZ2UuZ2V0QXR0cmlidXRlTmFtZXNNdXRhdGVkKCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhbmdlZEF0dHJOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gY2hhbmdlZEF0dHJOYW1lc1tqXTtcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZUZpbHRlciAmJiAhYXR0cmlidXRlRmlsdGVyW2F0dHJOYW1lXSAmJiAhKGNoYW5nZS5pc0Nhc2VJbnNlbnNpdGl2ZSAmJiBjYXNlSW5zZW5zaXRpdmVGaWx0ZXJbYXR0ck5hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBjaGFuZ2UuZ2V0QXR0cmlidXRlT2xkVmFsdWUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09PSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChjYXNlSW5zZW5zaXRpdmVGaWx0ZXIgJiYgY2hhbmdlLmlzQ2FzZUluc2Vuc2l0aXZlKVxuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gY2FzZUluc2Vuc2l0aXZlRmlsdGVyW2F0dHJOYW1lXTtcblxuICAgICAgICAgICAgcmVzdWx0W2F0dHJOYW1lXSA9IHJlc3VsdFthdHRyTmFtZV0gfHwgW107XG4gICAgICAgICAgICByZXN1bHRbYXR0ck5hbWVdLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuTXV0YXRpb25Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRPbGRDaGFyYWN0ZXJEYXRhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgY2hhbmdlID0gdGhpcy50cmVlQ2hhbmdlcy5nZXQobm9kZSk7XG4gICAgaWYgKCFjaGFuZ2UgfHwgIWNoYW5nZS5jaGFyYWN0ZXJEYXRhKVxuICAgICAgICB0aHJvdyBFcnJvcignZ2V0T2xkQ2hhcmFjdGVyRGF0YSByZXF1ZXN0ZWQgb24gaW52YWxpZCBub2RlLicpO1xuXG4gICAgcmV0dXJuIGNoYW5nZS5jaGFyYWN0ZXJEYXRhT2xkVmFsdWU7XG59O1xuXG5NdXRhdGlvblByb2plY3Rpb24ucHJvdG90eXBlLmdldENoYXJhY3RlckRhdGFDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy50cmVlQ2hhbmdlcy5hbnlDaGFyYWN0ZXJEYXRhQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgdmFyIG5vZGVzID0gdGhpcy50cmVlQ2hhbmdlcy5rZXlzKCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoMiAvKiBTVEFZRURfSU4gKi8gIT09IHRoaXMudHJlZUNoYW5nZXMucmVhY2hhYmlsaXR5Q2hhbmdlKHRhcmdldCkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgY2hhbmdlID0gdGhpcy50cmVlQ2hhbmdlcy5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UuY2hhcmFjdGVyRGF0YSB8fCB0YXJnZXQudGV4dENvbnRlbnQgPT0gY2hhbmdlLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUuY29tcHV0ZU1hdGNoYWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgZWwpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hDYWNoZSlcbiAgICAgICAgdGhpcy5tYXRjaENhY2hlID0gW107XG4gICAgaWYgKCF0aGlzLm1hdGNoQ2FjaGVbc2VsZWN0b3IudWlkXSlcbiAgICAgICAgdGhpcy5tYXRjaENhY2hlW3NlbGVjdG9yLnVpZF0gPSBuZXcgTm9kZU1hcCgpO1xuXG4gICAgdmFyIGNhY2hlID0gdGhpcy5tYXRjaENhY2hlW3NlbGVjdG9yLnVpZF07XG4gICAgdmFyIHJlc3VsdCA9IGNhY2hlLmdldChlbCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGVjdG9yLm1hdGNoYWJpbGl0eUNoYW5nZShlbCwgdGhpcy50cmVlQ2hhbmdlcy5nZXQoZWwpKTtcbiAgICAgICAgY2FjaGUuc2V0KGVsLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuTXV0YXRpb25Qcm9qZWN0aW9uLnByb3RvdHlwZS5tYXRjaGFiaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gVE9ETyhyYWZhZWx3KTogSW5jbHVkZSBQSSwgQ0RBVEE/XG4gICAgLy8gT25seSBpbmNsdWRlIHRleHQgbm9kZXMuXG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyRGF0YU9ubHkpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGUuQ09NTUVOVF9OT0RFOlxuICAgICAgICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBTVEFZRURfSU4gKi87XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIFNUQVlFRF9PVVQgKi87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBlbGVtZW50IGZpbHRlci4gSW5jbHVkZSBhbGwgbm9kZXMuXG4gICAgaWYgKCF0aGlzLnNlbGVjdG9ycylcbiAgICAgICAgcmV0dXJuIDIgLyogU1RBWUVEX0lOICovO1xuXG4gICAgLy8gRWxlbWVudCBmaWx0ZXIuIEV4Y2x1ZGUgbm9uLWVsZW1lbnRzLlxuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSlcbiAgICAgICAgcmV0dXJuIDAgLyogU1RBWUVEX09VVCAqLztcblxuICAgIHZhciBlbCA9IG5vZGU7XG5cbiAgICB2YXIgbWF0Y2hDaGFuZ2VzID0gdGhpcy5zZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29tcHV0ZU1hdGNoYWJpbGl0eUNoYW5nZShzZWxlY3RvciwgZWwpO1xuICAgIH0pO1xuXG4gICAgdmFyIGFjY3VtID0gMCAvKiBTVEFZRURfT1VUICovO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChhY2N1bSAhPT0gMiAvKiBTVEFZRURfSU4gKi8gJiYgaSA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgc3dpdGNoIChtYXRjaENoYW5nZXNbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBTVEFZRURfSU4gKi86XG4gICAgICAgICAgICAgICAgYWNjdW0gPSAyIC8qIFNUQVlFRF9JTiAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBFTlRFUkVEICovOlxuICAgICAgICAgICAgICAgIGlmIChhY2N1bSA9PT0gNSAvKiBFWElURUQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGFjY3VtID0gMiAvKiBTVEFZRURfSU4gKi87XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhY2N1bSA9IDEgLyogRU5URVJFRCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBFWElURUQgKi86XG4gICAgICAgICAgICAgICAgaWYgKGFjY3VtID09PSAxIC8qIEVOVEVSRUQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGFjY3VtID0gMiAvKiBTVEFZRURfSU4gKi87XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhY2N1bSA9IDUgLyogRVhJVEVEICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBhY2N1bTtcbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0Q2hpbGRsaXN0Q2hhbmdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRoaXMuY2hpbGRMaXN0Q2hhbmdlTWFwLmdldChlbCk7XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgY2hhbmdlID0gbmV3IENoaWxkTGlzdENoYW5nZSgpO1xuICAgICAgICB0aGlzLmNoaWxkTGlzdENoYW5nZU1hcC5zZXQoZWwsIGNoYW5nZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbn07XG5cbk11dGF0aW9uUHJvamVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc0NoaWxkbGlzdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRMaXN0Q2hhbmdlTWFwKVxuICAgICAgICByZXR1cm47XG5cbiAgICB0aGlzLmNoaWxkTGlzdENoYW5nZU1hcCA9IG5ldyBOb2RlTWFwKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtdXRhdGlvbiA9IHRoaXMubXV0YXRpb25zW2ldO1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSAhPSAnY2hpbGRMaXN0JylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICh0aGlzLnRyZWVDaGFuZ2VzLnJlYWNoYWJpbGl0eUNoYW5nZShtdXRhdGlvbi50YXJnZXQpICE9PSAyIC8qIFNUQVlFRF9JTiAqLyAmJiAhdGhpcy5jYWxjT2xkUHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNoYW5nZSA9IHRoaXMuZ2V0Q2hpbGRsaXN0Q2hhbmdlKG11dGF0aW9uLnRhcmdldCk7XG5cbiAgICAgICAgdmFyIG9sZFByZXZpb3VzID0gbXV0YXRpb24ucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlY29yZE9sZFByZXZpb3VzKG5vZGUsIHByZXZpb3VzKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgY2hhbmdlLm9sZFByZXZpb3VzLmhhcyhub2RlKSB8fCBjaGFuZ2UuYWRkZWQuaGFzKG5vZGUpIHx8IGNoYW5nZS5tYXliZU1vdmVkLmhhcyhub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiAoY2hhbmdlLmFkZGVkLmhhcyhwcmV2aW91cykgfHwgY2hhbmdlLm1heWJlTW92ZWQuaGFzKHByZXZpb3VzKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjaGFuZ2Uub2xkUHJldmlvdXMuc2V0KG5vZGUsIHByZXZpb3VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tqXTtcbiAgICAgICAgICAgIHJlY29yZE9sZFByZXZpb3VzKG5vZGUsIG9sZFByZXZpb3VzKTtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZS5hZGRlZC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkZWQuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UucmVtb3ZlZC5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlLm1heWJlTW92ZWQuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbGRQcmV2aW91cyA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvcmRPbGRQcmV2aW91cyhtdXRhdGlvbi5uZXh0U2libGluZywgb2xkUHJldmlvdXMpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5yZW1vdmVkLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS5yZW1vdmVkLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2UubWF5YmVNb3ZlZC5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZS5hZGRlZC5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NdXRhdGlvblByb2plY3Rpb24ucHJvdG90eXBlLndhc1Jlb3JkZXJlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCF0aGlzLnRyZWVDaGFuZ2VzLmFueVBhcmVudHNDaGFuZ2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB0aGlzLnByb2Nlc3NDaGlsZGxpc3RDaGFuZ2VzKCk7XG5cbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgbm9kZUNoYW5nZSA9IHRoaXMudHJlZUNoYW5nZXMuZ2V0KG5vZGUpO1xuICAgIGlmIChub2RlQ2hhbmdlICYmIG5vZGVDaGFuZ2Uub2xkUGFyZW50Tm9kZSlcbiAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGVDaGFuZ2Uub2xkUGFyZW50Tm9kZTtcblxuICAgIHZhciBjaGFuZ2UgPSB0aGlzLmNoaWxkTGlzdENoYW5nZU1hcC5nZXQocGFyZW50Tm9kZSk7XG4gICAgaWYgKCFjaGFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChjaGFuZ2UubW92ZWQpXG4gICAgICAgIHJldHVybiBjaGFuZ2UubW92ZWQuZ2V0KG5vZGUpO1xuXG4gICAgY2hhbmdlLm1vdmVkID0gbmV3IE5vZGVNYXAoKTtcbiAgICB2YXIgcGVuZGluZ01vdmVEZWNpc2lvbiA9IG5ldyBOb2RlTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBpc01vdmVkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWNoYW5nZS5tYXliZU1vdmVkLmhhcyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgZGlkTW92ZSA9IGNoYW5nZS5tb3ZlZC5nZXQobm9kZSk7XG4gICAgICAgIGlmIChkaWRNb3ZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZGlkTW92ZTtcblxuICAgICAgICBpZiAocGVuZGluZ01vdmVEZWNpc2lvbi5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIGRpZE1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVuZGluZ01vdmVEZWNpc2lvbi5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBkaWRNb3ZlID0gZ2V0UHJldmlvdXMobm9kZSkgIT09IGdldE9sZFByZXZpb3VzKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlbmRpbmdNb3ZlRGVjaXNpb24uaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICBwZW5kaW5nTW92ZURlY2lzaW9uLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIGNoYW5nZS5tb3ZlZC5zZXQobm9kZSwgZGlkTW92ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWRNb3ZlID0gY2hhbmdlLm1vdmVkLmdldChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaWRNb3ZlO1xuICAgIH1cblxuICAgIHZhciBvbGRQcmV2aW91c0NhY2hlID0gbmV3IE5vZGVNYXAoKTtcbiAgICBmdW5jdGlvbiBnZXRPbGRQcmV2aW91cyhub2RlKSB7XG4gICAgICAgIHZhciBvbGRQcmV2aW91cyA9IG9sZFByZXZpb3VzQ2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAob2xkUHJldmlvdXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBvbGRQcmV2aW91cztcblxuICAgICAgICBvbGRQcmV2aW91cyA9IGNoYW5nZS5vbGRQcmV2aW91cy5nZXQobm9kZSk7XG4gICAgICAgIHdoaWxlIChvbGRQcmV2aW91cyAmJiAoY2hhbmdlLnJlbW92ZWQuaGFzKG9sZFByZXZpb3VzKSB8fCBpc01vdmVkKG9sZFByZXZpb3VzKSkpIHtcbiAgICAgICAgICAgIG9sZFByZXZpb3VzID0gZ2V0T2xkUHJldmlvdXMob2xkUHJldmlvdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZFByZXZpb3VzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvbGRQcmV2aW91cyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBvbGRQcmV2aW91c0NhY2hlLnNldChub2RlLCBvbGRQcmV2aW91cyk7XG5cbiAgICAgICAgcmV0dXJuIG9sZFByZXZpb3VzO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c0NhY2hlID0gbmV3IE5vZGVNYXAoKTtcbiAgICBmdW5jdGlvbiBnZXRQcmV2aW91cyhub2RlKSB7XG4gICAgICAgIGlmIChwcmV2aW91c0NhY2hlLmhhcyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c0NhY2hlLmdldChub2RlKTtcblxuICAgICAgICB2YXIgcHJldmlvdXMgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgd2hpbGUgKHByZXZpb3VzICYmIChjaGFuZ2UuYWRkZWQuaGFzKHByZXZpb3VzKSB8fCBpc01vdmVkKHByZXZpb3VzKSkpXG4gICAgICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzU2libGluZztcblxuICAgICAgICBwcmV2aW91c0NhY2hlLnNldChub2RlLCBwcmV2aW91cyk7XG4gICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG5cbiAgICBjaGFuZ2UubWF5YmVNb3ZlZC5rZXlzKCkuZm9yRWFjaChpc01vdmVkKTtcbiAgICByZXR1cm4gY2hhbmdlLm1vdmVkLmdldChub2RlKTtcbn07XG5cbmZ1bmN0aW9uIFN1bW1hcnkocHJvamVjdGlvbiwgcXVlcnkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgdGhpcy5hZGRlZCA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZCA9IFtdO1xuICAgIHRoaXMucmVwYXJlbnRlZCA9IHF1ZXJ5LmFsbCB8fCBxdWVyeS5lbGVtZW50ID8gW10gOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZW9yZGVyZWQgPSBxdWVyeS5hbGwgPyBbXSA6IHVuZGVmaW5lZDtcblxuICAgIHByb2plY3Rpb24uZ2V0Q2hhbmdlZCh0aGlzLCBxdWVyeS5lbGVtZW50RmlsdGVyLCBxdWVyeS5jaGFyYWN0ZXJEYXRhKTtcblxuICAgIGlmIChxdWVyeS5hbGwgfHwgcXVlcnkuYXR0cmlidXRlIHx8IHF1ZXJ5LmF0dHJpYnV0ZUxpc3QpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSBxdWVyeS5hdHRyaWJ1dGUgPyBbcXVlcnkuYXR0cmlidXRlXSA6IHF1ZXJ5LmF0dHJpYnV0ZUxpc3Q7XG4gICAgICB2YXIgYXR0cmlidXRlQ2hhbmdlZCA9IHByb2plY3Rpb24uYXR0cmlidXRlQ2hhbmdlZE5vZGVzKGZpbHRlcik7XG5cbiAgICAgIGlmIChxdWVyeS5hdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQgPSBhdHRyaWJ1dGVDaGFuZ2VkW3F1ZXJ5LmF0dHJpYnV0ZV0gfHwgW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWQgPSBhdHRyaWJ1dGVDaGFuZ2VkO1xuICAgICAgICBpZiAocXVlcnkuYXR0cmlidXRlTGlzdCkge1xuICAgICAgICAgIHF1ZXJ5LmF0dHJpYnV0ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuYXR0cmlidXRlQ2hhbmdlZC5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpXG4gICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZUNoYW5nZWRbYXR0ck5hbWVdID0gW107XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocXVlcnkuYWxsIHx8IHF1ZXJ5LmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlckRhdGFDaGFuZ2VkID0gcHJvamVjdGlvbi5nZXRDaGFyYWN0ZXJEYXRhQ2hhbmdlZCgpO1xuXG4gICAgICAgIGlmIChxdWVyeS5jaGFyYWN0ZXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQgPSBjaGFyYWN0ZXJEYXRhQ2hhbmdlZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXJEYXRhQ2hhbmdlZCA9IGNoYXJhY3RlckRhdGFDaGFuZ2VkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlb3JkZXJlZClcbiAgICAgICAgdGhpcy5nZXRPbGRQcmV2aW91c1NpYmxpbmcgPSBwcm9qZWN0aW9uLmdldE9sZFByZXZpb3VzU2libGluZy5iaW5kKHByb2plY3Rpb24pO1xufVxuXG5TdW1tYXJ5LnByb3RvdHlwZS5nZXRPbGRQYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uLmdldE9sZFBhcmVudE5vZGUobm9kZSk7XG59O1xuXG5TdW1tYXJ5LnByb3RvdHlwZS5nZXRPbGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb24uZ2V0T2xkQXR0cmlidXRlKG5vZGUsIG5hbWUpO1xufTtcblxuU3VtbWFyeS5wcm90b3R5cGUuZ2V0T2xkQ2hhcmFjdGVyRGF0YSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbi5nZXRPbGRDaGFyYWN0ZXJEYXRhKG5vZGUpO1xufTtcblxuU3VtbWFyeS5wcm90b3R5cGUuZ2V0T2xkUHJldmlvdXNTaWJsaW5nID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uLmdldE9sZFByZXZpb3VzU2libGluZyhub2RlKTtcbn07XG5cbi8vIFRPRE8gKHJhZmFlbHcpOiBBbGxvdyAnOicgYW5kICcuJyBhcyB2YWxpZCBuYW1lIGNoYXJhY3RlcnMuXG52YXIgdmFsaWROYW1lSW5pdGlhbENoYXIgPSAvW2EtekEtWl9dKy87XG52YXIgdmFsaWROYW1lTm9uSW5pdGlhbENoYXIgPSAvW2EtekEtWjAtOV9cXC1dKy87XG5cbi8vIFRPRE86IENvbnNpZGVyIGFsbG93aW5nIGJhY2tzbGFzaCBpbiB0aGUgYXR0clZhbHVlLlxuLy8gVE9ETzogVGhlcmUncyBnb3QgYSB0byBiZSB3YXkgdG8gcmVwcmVzZW50IHRoaXMgc3RhdGUgbWFjaGluZVxuLy8gbW9yZSBjb21wYWN0bHk/Pz9cbmZ1bmN0aW9uIGVzY2FwZVF1b3Rlcyh2YWx1ZSkge1xuICAgIHJldHVybiAnXCInICsgdmFsdWUucmVwbGFjZSgvXCIvLCAnXFxcXFxcXCInKSArICdcIic7XG59XG5cbmZ1bmN0aW9uIFF1YWxpZmllcigpIHtcbn1cblxuUXVhbGlmaWVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG9sZFZhbHVlKSB7XG4gIGlmIChvbGRWYWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHRoaXMuYXR0clZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgaWYgKCF0aGlzLmNvbnRhaW5zKVxuICAgIHJldHVybiB0aGlzLmF0dHJWYWx1ZSA9PSBvbGRWYWx1ZTtcblxuICB2YXIgdG9rZW5zID0gb2xkVmFsdWUuc3BsaXQoJyAnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5hdHRyVmFsdWUgPT09IHRva2Vuc1tpXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5RdWFsaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hdHRyTmFtZSA9PT0gJ2NsYXNzJyAmJiB0aGlzLmNvbnRhaW5zKVxuICAgIHJldHVybiAnLicgKyB0aGlzLmF0dHJWYWx1ZTtcblxuICBpZiAodGhpcy5hdHRyTmFtZSA9PT0gJ2lkJyAmJiAhdGhpcy5jb250YWlucylcbiAgICByZXR1cm4gJyMnICsgdGhpcy5hdHRyVmFsdWU7XG5cbiAgaWYgKHRoaXMuY29udGFpbnMpXG4gICAgcmV0dXJuICdbJyArIHRoaXMuYXR0ck5hbWUgKyAnfj0nICsgZXNjYXBlUXVvdGVzKHRoaXMuYXR0clZhbHVlKSArICddJztcblxuICBpZiAoJ2F0dHJWYWx1ZScgaW4gdGhpcylcbiAgICByZXR1cm4gJ1snICsgdGhpcy5hdHRyTmFtZSArICc9JyArIGVzY2FwZVF1b3Rlcyh0aGlzLmF0dHJWYWx1ZSkgKyAnXSc7XG5cbiAgcmV0dXJuICdbJyArIHRoaXMuYXR0ck5hbWUgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIFNlbGVjdG9yKCkge1xuICAgIHRoaXMubmV4dFVpZCA9IDE7XG4gICAgdGhpcy51aWQgPSB0aGlzLm5leHRVaWQrKztcbiAgICB0aGlzLnF1YWxpZmllcnMgPSBbXTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdG9yLnByb3RvdHlwZSwgXCJjYXNlSW5zZW5zaXRpdmVUYWdOYW1lXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2VsZWN0b3IucHJvdG90eXBlLCBcInNlbGVjdG9yU3RyaW5nXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnTmFtZSArIHRoaXMucXVhbGlmaWVycy5qb2luKCcnKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuU2VsZWN0b3IucHJvdG90eXBlLmlzTWF0Y2hpbmcgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWxbdGhpcy5tYXRjaGVzU2VsZWN0b3JdKHRoaXMuc2VsZWN0b3JTdHJpbmcpO1xufTtcblxuU2VsZWN0b3IucHJvdG90eXBlLndhc01hdGNoaW5nID0gZnVuY3Rpb24gKGVsLCBjaGFuZ2UsIGlzTWF0Y2hpbmcpIHtcbiAgICBpZiAoIWNoYW5nZSB8fCAhY2hhbmdlLmF0dHJpYnV0ZXMpXG4gICAgICAgIHJldHVybiBpc01hdGNoaW5nO1xuXG4gICAgdmFyIHRhZ05hbWUgPSBjaGFuZ2UuaXNDYXNlSW5zZW5zaXRpdmUgPyB0aGlzLmNhc2VJbnNlbnNpdGl2ZVRhZ05hbWUgOiB0aGlzLnRhZ05hbWU7XG4gICAgaWYgKHRhZ05hbWUgIT09ICcqJyAmJiB0YWdOYW1lICE9PSBlbC50YWdOYW1lKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgYXR0cmlidXRlT2xkVmFsdWVzID0gW107XG4gICAgdmFyIGFueUNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVhbGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcXVhbGlmaWVyID0gdGhpcy5xdWFsaWZpZXJzW2ldO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBjaGFuZ2UuZ2V0QXR0cmlidXRlT2xkVmFsdWUocXVhbGlmaWVyLmF0dHJOYW1lKTtcbiAgICAgICAgYXR0cmlidXRlT2xkVmFsdWVzLnB1c2gob2xkVmFsdWUpO1xuICAgICAgICBhbnlDaGFuZ2VkID0gYW55Q2hhbmdlZCB8fCAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgaWYgKCFhbnlDaGFuZ2VkKVxuICAgICAgICByZXR1cm4gaXNNYXRjaGluZztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWFsaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBxdWFsaWZpZXIgPSB0aGlzLnF1YWxpZmllcnNbaV07XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGF0dHJpYnV0ZU9sZFZhbHVlc1tpXTtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShxdWFsaWZpZXIuYXR0ck5hbWUpO1xuICAgICAgICBpZiAoIXF1YWxpZmllci5tYXRjaGVzKG9sZFZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblNlbGVjdG9yLnByb3RvdHlwZS5tYXRjaGFiaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiAoZWwsIGNoYW5nZSkge1xuICAgIHZhciBpc01hdGNoaW5nID0gdGhpcy5pc01hdGNoaW5nKGVsKTtcbiAgICBpZiAoaXNNYXRjaGluZylcbiAgICAgICAgcmV0dXJuIHRoaXMud2FzTWF0Y2hpbmcoZWwsIGNoYW5nZSwgaXNNYXRjaGluZykgPyAyIC8qIFNUQVlFRF9JTiAqLyA6IDEgLyogRU5URVJFRCAqLztcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLndhc01hdGNoaW5nKGVsLCBjaGFuZ2UsIGlzTWF0Y2hpbmcpID8gNSAvKiBFWElURUQgKi8gOiAwIC8qIFNUQVlFRF9PVVQgKi87XG59O1xuXG5TZWxlY3Rvci5wYXJzZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3RvcnMgPSBbXTtcbiAgICB2YXIgY3VycmVudFNlbGVjdG9yO1xuICAgIHZhciBjdXJyZW50UXVhbGlmaWVyO1xuXG4gICAgZnVuY3Rpb24gbmV3U2VsZWN0b3IoKSB7XG4gICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVhbGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdG9yLnF1YWxpZmllcnMucHVzaChjdXJyZW50UXVhbGlmaWVyKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChjdXJyZW50U2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRTZWxlY3RvciA9IG5ldyBTZWxlY3RvcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld1F1YWxpZmllcigpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRRdWFsaWZpZXIpXG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0b3IucXVhbGlmaWVycy5wdXNoKGN1cnJlbnRRdWFsaWZpZXIpO1xuXG4gICAgICAgIGN1cnJlbnRRdWFsaWZpZXIgPSBuZXcgUXVhbGlmaWVyKCk7XG4gICAgfVxuXG4gICAgdmFyIFdISVRFU1BBQ0UgPSAvXFxzLztcbiAgICB2YXIgdmFsdWVRdW90ZUNoYXI7XG4gICAgdmFyIFNZTlRBWF9FUlJPUiA9ICdJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHNlbGVjdG9yIHN5bnRheC4nO1xuXG4gICAgdmFyIFNFTEVDVE9SID0gMTtcbiAgICB2YXIgVEFHX05BTUUgPSAyO1xuICAgIHZhciBRVUFMSUZJRVIgPSAzO1xuICAgIHZhciBRVUFMSUZJRVJfTkFNRV9GSVJTVF9DSEFSID0gNDtcbiAgICB2YXIgUVVBTElGSUVSX05BTUUgPSA1O1xuICAgIHZhciBBVFRSX05BTUVfRklSU1RfQ0hBUiA9IDY7XG4gICAgdmFyIEFUVFJfTkFNRSA9IDc7XG4gICAgdmFyIEVRVUlWX09SX0FUVFJfUVVBTF9FTkQgPSA4O1xuICAgIHZhciBFUVVBTCA9IDk7XG4gICAgdmFyIEFUVFJfUVVBTF9FTkQgPSAxMDtcbiAgICB2YXIgVkFMVUVfRklSU1RfQ0hBUiA9IDExO1xuICAgIHZhciBWQUxVRSA9IDEyO1xuICAgIHZhciBRVU9URURfVkFMVUUgPSAxMztcbiAgICB2YXIgU0VMRUNUT1JfU0VQQVJBVE9SID0gMTQ7XG5cbiAgICB2YXIgc3RhdGUgPSBTRUxFQ1RPUjtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBpbnB1dFtpKytdO1xuXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgU0VMRUNUT1I6XG4gICAgICAgICAgICAgICAgaWYgKGMubWF0Y2godmFsaWROYW1lSW5pdGlhbENoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rvci50YWdOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBUQUdfTkFNRTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rvci50YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFFVQUxJRklFUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3IudGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyTmFtZSA9ICdjbGFzcyc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWFsaWZpZXIuY29udGFpbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFFVQUxJRklFUl9OQU1FX0ZJUlNUX0NIQVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UXVhbGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rvci50YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lID0gJ2lkJztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3IudGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEFUVFJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy5tYXRjaChXSElURVNQQUNFKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihTWU5UQVhfRVJST1IpO1xuXG4gICAgICAgICAgICBjYXNlIFRBR19OQU1FOlxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKHZhbGlkTmFtZU5vbkluaXRpYWxDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3IudGFnTmFtZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UXVhbGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWFsaWZpZXIuYXR0ck5hbWUgPSAnY2xhc3MnO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmNvbnRhaW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lID0gJ2lkJztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gQVRUUl9OQU1FX0ZJUlNUX0NIQVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKFdISVRFU1BBQ0UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU0VMRUNUT1JfU0VQQVJBVE9SO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTRUxFQ1RPUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoU1lOVEFYX0VSUk9SKTtcblxuICAgICAgICAgICAgY2FzZSBRVUFMSUZJRVI6XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lID0gJ2NsYXNzJztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5jb250YWlucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gUVVBTElGSUVSX05BTUVfRklSU1RfQ0hBUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjID09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdRdWFsaWZpZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyTmFtZSA9ICdpZCc7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gUVVBTElGSUVSX05BTUVfRklSU1RfQ0hBUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjID09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdRdWFsaWZpZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyTmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEFUVFJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy5tYXRjaChXSElURVNQQUNFKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNFTEVDVE9SX1NFUEFSQVRPUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU0VMRUNUT1I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFNZTlRBWF9FUlJPUik7XG5cbiAgICAgICAgICAgIGNhc2UgUVVBTElGSUVSX05BTUVfRklSU1RfQ0hBUjpcbiAgICAgICAgICAgICAgICBpZiAoYy5tYXRjaCh2YWxpZE5hbWVJbml0aWFsQ2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyVmFsdWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFFVQUxJRklFUl9OQU1FO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihTWU5UQVhfRVJST1IpO1xuXG4gICAgICAgICAgICBjYXNlIFFVQUxJRklFUl9OQU1FOlxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKHZhbGlkTmFtZU5vbkluaXRpYWxDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJWYWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UXVhbGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWFsaWZpZXIuYXR0ck5hbWUgPSAnY2xhc3MnO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmNvbnRhaW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lID0gJ2lkJztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1F1YWxpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEFUVFJfTkFNRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy5tYXRjaChXSElURVNQQUNFKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNFTEVDVE9SX1NFUEFSQVRPUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjID09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNFTEVDVE9SO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihTWU5UQVhfRVJST1IpO1xuXG4gICAgICAgICAgICBjYXNlIEFUVFJfTkFNRV9GSVJTVF9DSEFSOlxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKHZhbGlkTmFtZUluaXRpYWxDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBBVFRSX05BTUU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKFdISVRFU1BBQ0UpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFNZTlRBWF9FUlJPUik7XG5cbiAgICAgICAgICAgIGNhc2UgQVRUUl9OQU1FOlxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKHZhbGlkTmFtZU5vbkluaXRpYWxDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJOYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKFdISVRFU1BBQ0UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gRVFVSVZfT1JfQVRUUl9RVUFMX0VORDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ34nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWFsaWZpZXIuY29udGFpbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEVRVUFMO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBWQUxVRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFNZTlRBWF9FUlJPUik7XG5cbiAgICAgICAgICAgIGNhc2UgRVFVSVZfT1JfQVRUUl9RVUFMX0VORDpcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnficpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5jb250YWlucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gRVFVQUw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjID09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFZBTFVFX0ZJUlNUX0NIQVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjID09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFFVQUxJRklFUjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMubWF0Y2goV0hJVEVTUEFDRSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoU1lOVEFYX0VSUk9SKTtcblxuICAgICAgICAgICAgY2FzZSBFUVVBTDpcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1YWxpZmllci5hdHRyVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBWQUxVRV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihTWU5UQVhfRVJST1IpO1xuXG4gICAgICAgICAgICBjYXNlIEFUVFJfUVVBTF9FTkQ6XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gUVVBTElGSUVSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy5tYXRjaChXSElURVNQQUNFKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihTWU5UQVhfRVJST1IpO1xuXG4gICAgICAgICAgICBjYXNlIFZBTFVFX0ZJUlNUX0NIQVI6XG4gICAgICAgICAgICAgICAgaWYgKGMubWF0Y2goV0hJVEVTUEFDRSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ1wiJyB8fCBjID09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUXVvdGVDaGFyID0gYztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVU9URURfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWFsaWZpZXIuYXR0clZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBWQUxVRTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBWQUxVRTpcbiAgICAgICAgICAgICAgICBpZiAoYy5tYXRjaChXSElURVNQQUNFKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEFUVFJfUVVBTF9FTkQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBRVUFMSUZJRVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyA9PSBcIidcIiB8fCBjID09ICdcIicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFNZTlRBWF9FUlJPUik7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50UXVhbGlmaWVyLmF0dHJWYWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFFVT1RFRF9WQUxVRTpcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSB2YWx1ZVF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEFUVFJfUVVBTF9FTkQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWFsaWZpZXIuYXR0clZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU0VMRUNUT1JfU0VQQVJBVE9SOlxuICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKFdISVRFU1BBQ0UpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGlmIChjID09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNFTEVDVE9SO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihTWU5UQVhfRVJST1IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNFTEVDVE9SOlxuICAgICAgICBjYXNlIFRBR19OQU1FOlxuICAgICAgICBjYXNlIFFVQUxJRklFUjpcbiAgICAgICAgY2FzZSBRVUFMSUZJRVJfTkFNRTpcbiAgICAgICAgY2FzZSBTRUxFQ1RPUl9TRVBBUkFUT1I6XG4gICAgICAgICAgICAvLyBWYWxpZCBlbmQgc3RhdGVzLlxuICAgICAgICAgICAgbmV3U2VsZWN0b3IoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoU1lOVEFYX0VSUk9SKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGVjdG9ycy5sZW5ndGgpXG4gICAgICAgIHRocm93IEVycm9yKFNZTlRBWF9FUlJPUik7XG5cbiAgICByZXR1cm4gc2VsZWN0b3JzO1xufTtcblxuU2VsZWN0b3IubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50Wyd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudFsnbW96TWF0Y2hlc1NlbGVjdG9yJ10gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiAnbW96TWF0Y2hlc1NlbGVjdG9yJztcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRbJ21zTWF0Y2hlc1NlbGVjdG9yJ10gPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiAnbXNNYXRjaGVzU2VsZWN0b3InO1xuXG4gICAgcmV0dXJuICdtYXRjaGVzU2VsZWN0b3InO1xufVxuXG52YXIgYXR0cmlidXRlRmlsdGVyUGF0dGVybiA9IC9eKFthLXpBLVo6X10rW2EtekEtWjAtOV9cXC06XFwuXSopJC87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlICE9ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXF1ZXN0IG9waW9uLiBhdHRyaWJ1dGUgbXVzdCBiZSBhIG5vbi16ZXJvIGxlbmd0aCBzdHJpbmcuJyk7XG5cbiAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUudHJpbSgpO1xuXG4gICAgaWYgKCFhdHRyaWJ1dGUpXG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHJlcXVlc3Qgb3Bpb24uIGF0dHJpYnV0ZSBtdXN0IGJlIGEgbm9uLXplcm8gbGVuZ3RoIHN0cmluZy4nKTtcblxuICAgIGlmICghYXR0cmlidXRlLm1hdGNoKGF0dHJpYnV0ZUZpbHRlclBhdHRlcm4pKVxuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXF1ZXN0IG9wdGlvbi4gaW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogJyArIGF0dHJpYnV0ZSk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVsZW1lbnRBdHRyaWJ1dGVzKGF0dHJpYnMpIHtcbiAgICBpZiAoIWF0dHJpYnMudHJpbSgpLmxlbmd0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCBvcHRpb246IGVsZW1lbnRBdHRyaWJ1dGVzIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgYXR0cmlidXRlLicpO1xuXG4gICAgdmFyIGxvd2VyQXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG5cbiAgICB2YXIgdG9rZW5zID0gYXR0cmlicy5zcGxpdCgvXFxzKy8pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgbmFtZSA9IHZhbGlkYXRlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB2YXIgbmFtZUxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJBdHRyaWJ1dGVzW25hbWVMb3dlcl0pXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXF1ZXN0IG9wdGlvbjogb2JzZXJ2aW5nIG11bHRpcGxlIGNhc2UgdmFyaWF0aW9ucyBvZiB0aGUgc2FtZSBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZC4nKTtcblxuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgbG93ZXJBdHRyaWJ1dGVzW25hbWVMb3dlcl0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudEZpbHRlckF0dHJpYnV0ZXMoc2VsZWN0b3JzKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICBzZWxlY3Rvci5xdWFsaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKHF1YWxpZmllcikge1xuICAgICAgICAgICAgYXR0cmlidXRlc1txdWFsaWZpZXIuYXR0ck5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG59XG5cbmZ1bmN0aW9uIE11dGF0aW9uU3VtbWFyeShvcHRzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5vcHRpb25zID0gdGhpcy52YWxpZGF0ZU9wdGlvbnMob3B0cyk7XG4gIHRoaXMub2JzZXJ2ZXJPcHRpb25zID0gdGhpcy5jcmVhdGVPYnNlcnZlck9wdGlvbnModGhpcy5vcHRpb25zLnF1ZXJpZXMpO1xuICB0aGlzLnJvb3QgPSB0aGlzLm9wdGlvbnMucm9vdE5vZGU7XG4gIHRoaXMuY2FsbGJhY2sgPSB0aGlzLm9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgdGhpcy5lbGVtZW50RmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdGhpcy5vcHRpb25zLnF1ZXJpZXMubWFwKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5lbGVtZW50RmlsdGVyID8gcXVlcnkuZWxlbWVudEZpbHRlciA6IFtdO1xuICB9KSk7XG5cbiAgaWYgKCF0aGlzLmVsZW1lbnRGaWx0ZXIubGVuZ3RoKVxuICAgIHRoaXMuZWxlbWVudEZpbHRlciA9IHVuZGVmaW5lZDtcblxuICB0aGlzLmNhbGNSZW9yZGVyZWQgPSB0aGlzLm9wdGlvbnMucXVlcmllcy5zb21lKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHJldHVybiBxdWVyeS5hbGw7XG4gIH0pO1xuXG4gIHRoaXMucXVlcnlWYWxpZGF0b3JzID0gW107XG5cbiAgaWYgKHRoaXMuY3JlYXRlUXVlcnlWYWxpZGF0b3IpIHtcbiAgICB0aGlzLnF1ZXJ5VmFsaWRhdG9ycyA9IHRoaXMub3B0aW9ucy5xdWVyaWVzLm1hcChmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVF1ZXJ5VmFsaWRhdG9yKF90aGlzLnJvb3QsIHF1ZXJ5KTtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlckN0b3IoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgIF90aGlzLm9ic2VydmVyQ2FsbGJhY2sobXV0YXRpb25zKTtcbiAgfSk7XG5cbiAgdGhpcy5yZWNvbm5lY3QoKTtcbn1cblxuTXV0YXRpb25TdW1tYXJ5LnByb3RvdHlwZS5jcmVhdGVPYnNlcnZlck9wdGlvbnMgPSBmdW5jdGlvbiAocXVlcmllcykge1xuXG4gIHZhciBvYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gIH07XG5cbiAgdmFyIGF0dHJpYnV0ZUZpbHRlcjtcblxuICBmdW5jdGlvbiBvYnNlcnZlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKG9ic2VydmVyT3B0aW9ucy5hdHRyaWJ1dGVzICYmICFhdHRyaWJ1dGVGaWx0ZXIpXG4gICAgICByZXR1cm47XG5cbiAgICBvYnNlcnZlck9wdGlvbnMuYXR0cmlidXRlcyA9IHRydWU7XG4gICAgb2JzZXJ2ZXJPcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlID0gdHJ1ZTtcblxuICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICAvLyBvYnNlcnZlIGFsbC5cbiAgICAgICAgYXR0cmlidXRlRmlsdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIG9ic2VydmVkLlxuICAgIGF0dHJpYnV0ZUZpbHRlciA9IGF0dHJpYnV0ZUZpbHRlciB8fCB7fTtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlRmlsdGVyW2F0dHJpYnV0ZV0gPSB0cnVlO1xuICAgICAgYXR0cmlidXRlRmlsdGVyW2F0dHJpYnV0ZS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBxdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5LmNoYXJhY3RlckRhdGEpIHtcbiAgICAgIG9ic2VydmVyT3B0aW9ucy5jaGFyYWN0ZXJEYXRhID0gdHJ1ZTtcbiAgICAgIG9ic2VydmVyT3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5hbGwpIHtcbiAgICAgIG9ic2VydmVBdHRyaWJ1dGVzKCk7XG4gICAgICBvYnNlcnZlck9wdGlvbnMuY2hhcmFjdGVyRGF0YSA9IHRydWU7XG4gICAgICBvYnNlcnZlck9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuYXR0cmlidXRlKSB7XG4gICAgICBvYnNlcnZlQXR0cmlidXRlcyhbcXVlcnkuYXR0cmlidXRlLnRyaW0oKV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudEZpbHRlckF0dHJpYnV0ZXMocXVlcnkuZWxlbWVudEZpbHRlcikuY29uY2F0KHF1ZXJ5LmF0dHJpYnV0ZUxpc3QgfHwgW10pO1xuICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aClcbiAgICAgIG9ic2VydmVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICB9KTtcblxuICBpZiAoYXR0cmlidXRlRmlsdGVyKVxuICAgIG9ic2VydmVyT3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVGaWx0ZXIpO1xuXG4gIHJldHVybiBvYnNlcnZlck9wdGlvbnM7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkucHJvdG90eXBlLnZhbGlkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCEocHJvcCBpbiBNdXRhdGlvblN1bW1hcnkub3B0aW9uS2V5cykpXG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBvcHRpb246ICcgKyBwcm9wKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG9wdGlvbnM6IGNhbGxiYWNrIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIW9wdGlvbnMucXVlcmllcyB8fCAhb3B0aW9ucy5xdWVyaWVzLmxlbmd0aClcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG9wdGlvbnM6IHF1ZXJpZXMgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBxdWVyeSByZXF1ZXN0IG9iamVjdC4nKTtcblxuICB2YXIgb3B0cyA9IHtcbiAgICAgIGNhbGxiYWNrOiBvcHRpb25zLmNhbGxiYWNrLFxuICAgICAgcm9vdE5vZGU6IG9wdGlvbnMucm9vdE5vZGUgfHwgZG9jdW1lbnQsXG4gICAgICBvYnNlcnZlT3duQ2hhbmdlczogISFvcHRpb25zLm9ic2VydmVPd25DaGFuZ2VzLFxuICAgICAgb2xkUHJldmlvdXNTaWJsaW5nOiAhIW9wdGlvbnMub2xkUHJldmlvdXNTaWJsaW5nLFxuICAgICAgcXVlcmllczogW11cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXF1ZXN0ID0gb3B0aW9ucy5xdWVyaWVzW2ldO1xuXG4gICAgLy8gYWxsXG4gICAgaWYgKHJlcXVlc3QuYWxsKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0KS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCBvcHRpb24uIGFsbCBoYXMgbm8gb3B0aW9ucy4nKTtcblxuICAgICAgICBvcHRzLnF1ZXJpZXMucHVzaCh7IGFsbDogdHJ1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYXR0cmlidXRlXG4gICAgaWYgKCdhdHRyaWJ1dGUnIGluIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgYXR0cmlidXRlOiB2YWxpZGF0ZUF0dHJpYnV0ZShyZXF1ZXN0LmF0dHJpYnV0ZSlcbiAgICAgICAgfTtcblxuICAgICAgICBxdWVyeS5lbGVtZW50RmlsdGVyID0gU2VsZWN0b3IucGFyc2VTZWxlY3RvcnMoJypbJyArIHF1ZXJ5LmF0dHJpYnV0ZSArICddJyk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcXVlc3QpLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXF1ZXN0IG9wdGlvbi4gYXR0cmlidXRlIGhhcyBubyBvcHRpb25zLicpO1xuXG4gICAgICAgIG9wdHMucXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZWxlbWVudFxuICAgIGlmICgnZWxlbWVudCcgaW4gcmVxdWVzdCkge1xuICAgICAgdmFyIHJlcXVlc3RPcHRpb25Db3VudCA9IE9iamVjdC5rZXlzKHJlcXVlc3QpLmxlbmd0aDtcbiAgICAgIHZhciBxdWVyeSA9IHtcbiAgICAgICAgICBlbGVtZW50OiByZXF1ZXN0LmVsZW1lbnQsXG4gICAgICAgICAgZWxlbWVudEZpbHRlcjogU2VsZWN0b3IucGFyc2VTZWxlY3RvcnMocmVxdWVzdC5lbGVtZW50KVxuICAgICAgfTtcblxuICAgICAgaWYgKHJlcXVlc3QuaGFzT3duUHJvcGVydHkoJ2VsZW1lbnRBdHRyaWJ1dGVzJykpIHtcbiAgICAgICAgICBxdWVyeS5hdHRyaWJ1dGVMaXN0ID0gdmFsaWRhdGVFbGVtZW50QXR0cmlidXRlcyhyZXF1ZXN0LmVsZW1lbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICByZXF1ZXN0T3B0aW9uQ291bnQtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3RPcHRpb25Db3VudCA+IDEpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCBvcHRpb24uIGVsZW1lbnQgb25seSBhbGxvd3MgZWxlbWVudEF0dHJpYnV0ZXMgb3B0aW9uLicpO1xuXG4gICAgICBvcHRzLnF1ZXJpZXMucHVzaChxdWVyeSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjaGFyYWN0ZXJEYXRhXG4gICAgaWYgKHJlcXVlc3QuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcXVlc3QpLmxlbmd0aCA+IDEpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCBvcHRpb24uIGNoYXJhY3RlckRhdGEgaGFzIG5vIG9wdGlvbnMuJyk7XG5cbiAgICAgIG9wdHMucXVlcmllcy5wdXNoKHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHJlcXVlc3Qgb3B0aW9uLiBVbmtub3duIHF1ZXJ5IHJlcXVlc3QuJyk7XG4gIH1cblxuICByZXR1cm4gb3B0cztcbn07XG5cbk11dGF0aW9uU3VtbWFyeS5wcm90b3R5cGUuY3JlYXRlU3VtbWFyaWVzID0gZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICBpZiAoIW11dGF0aW9ucyB8fCAhbXV0YXRpb25zLmxlbmd0aClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIHByb2plY3Rpb24gPSBuZXcgTXV0YXRpb25Qcm9qZWN0aW9uKHRoaXMucm9vdCwgbXV0YXRpb25zLCB0aGlzLmVsZW1lbnRGaWx0ZXIsIHRoaXMuY2FsY1Jlb3JkZXJlZCwgdGhpcy5vcHRpb25zLm9sZFByZXZpb3VzU2libGluZyk7XG5cbiAgdmFyIHN1bW1hcmllcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5xdWVyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtbWFyaWVzLnB1c2gobmV3IFN1bW1hcnkocHJvamVjdGlvbiwgdGhpcy5vcHRpb25zLnF1ZXJpZXNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBzdW1tYXJpZXM7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkucHJvdG90eXBlLmNoZWNrcG9pbnRRdWVyeVZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucXVlcnlWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgIGlmICh2YWxpZGF0b3IpXG4gICAgICB2YWxpZGF0b3IucmVjb3JkUHJldmlvdXNTdGF0ZSgpO1xuICB9KTtcbn07XG5cbk11dGF0aW9uU3VtbWFyeS5wcm90b3R5cGUucnVuUXVlcnlWYWxpZGF0b3JzID0gZnVuY3Rpb24gKHN1bW1hcmllcykge1xuICB0aGlzLnF1ZXJ5VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IsIGluZGV4KSB7XG4gICAgaWYgKHZhbGlkYXRvcilcbiAgICAgIHZhbGlkYXRvci52YWxpZGF0ZShzdW1tYXJpZXNbaW5kZXhdKTtcbiAgfSk7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkucHJvdG90eXBlLmNoYW5nZXNUb1JlcG9ydCA9IGZ1bmN0aW9uIChzdW1tYXJpZXMpIHtcbiAgcmV0dXJuIHN1bW1hcmllcy5zb21lKGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgdmFyIHN1bW1hcnlQcm9wcyA9IFtcbiAgICAgICAgJ2FkZGVkJywgJ3JlbW92ZWQnLCAncmVvcmRlcmVkJywgJ3JlcGFyZW50ZWQnLFxuICAgICAgICAndmFsdWVDaGFuZ2VkJywgJ2NoYXJhY3RlckRhdGFDaGFuZ2VkJ107XG4gICAgaWYgKHN1bW1hcnlQcm9wcy5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBzdW1tYXJ5W3Byb3BdICYmIHN1bW1hcnlbcHJvcF0ubGVuZ3RoO1xuICAgIH0pKVxuICAgIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKHN1bW1hcnkuYXR0cmlidXRlQ2hhbmdlZCkge1xuICAgICAgdmFyIGF0dHJOYW1lcyA9IE9iamVjdC5rZXlzKHN1bW1hcnkuYXR0cmlidXRlQ2hhbmdlZCk7XG4gICAgICB2YXIgYXR0cnNDaGFuZ2VkID0gYXR0ck5hbWVzLnNvbWUoZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICEhc3VtbWFyeS5hdHRyaWJ1dGVDaGFuZ2VkW2F0dHJOYW1lXS5sZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIGlmIChhdHRyc0NoYW5nZWQpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkucHJvdG90eXBlLm9ic2VydmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLm9ic2VydmVPd25DaGFuZ2VzKVxuICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gIHZhciBzdW1tYXJpZXMgPSB0aGlzLmNyZWF0ZVN1bW1hcmllcyhtdXRhdGlvbnMpO1xuICB0aGlzLnJ1blF1ZXJ5VmFsaWRhdG9ycyhzdW1tYXJpZXMpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMub2JzZXJ2ZU93bkNoYW5nZXMpXG4gICAgdGhpcy5jaGVja3BvaW50UXVlcnlWYWxpZGF0b3JzKCk7XG5cbiAgaWYgKHRoaXMuY2hhbmdlc1RvUmVwb3J0KHN1bW1hcmllcykpXG4gICAgdGhpcy5jYWxsYmFjayhzdW1tYXJpZXMpO1xuXG4gIC8vIGRpc2Nvbm5lY3QoKSBtYXkgaGF2ZSBiZWVuIGNhbGxlZCBkdXJpbmcgdGhlIGNhbGxiYWNrLlxuICBpZiAoIXRoaXMub3B0aW9ucy5vYnNlcnZlT3duQ2hhbmdlcyAmJiB0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMuY2hlY2twb2ludFF1ZXJ5VmFsaWRhdG9ycygpO1xuICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnJvb3QsIHRoaXMub2JzZXJ2ZXJPcHRpb25zKTtcbiAgfVxufTtcblxuTXV0YXRpb25TdW1tYXJ5LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZClcbiAgICB0aHJvdyBFcnJvcignQWxyZWFkeSBjb25uZWN0ZWQnKTtcblxuICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5yb290LCB0aGlzLm9ic2VydmVyT3B0aW9ucyk7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5jaGVja3BvaW50UXVlcnlWYWxpZGF0b3JzKCk7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkucHJvdG90eXBlLnRha2VTdW1tYXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jb25uZWN0ZWQpXG4gICAgdGhyb3cgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcblxuICB2YXIgc3VtbWFyaWVzID0gdGhpcy5jcmVhdGVTdW1tYXJpZXModGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgcmV0dXJuIHRoaXMuY2hhbmdlc1RvUmVwb3J0KHN1bW1hcmllcykgPyBzdW1tYXJpZXMgOiB1bmRlZmluZWQ7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdW1tYXJpZXMgPSB0aGlzLnRha2VTdW1tYXJpZXMoKTtcbiAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHJldHVybiBzdW1tYXJpZXM7XG59O1xuXG5NdXRhdGlvblN1bW1hcnkuTm9kZU1hcCA9IE5vZGVNYXA7XG5NdXRhdGlvblN1bW1hcnkucGFyc2VFbGVtZW50RmlsdGVyID0gU2VsZWN0b3IucGFyc2VTZWxlY3RvcnM7XG5NdXRhdGlvblN1bW1hcnkub3B0aW9uS2V5cyA9IHtcbiAgICAnY2FsbGJhY2snOiB0cnVlLFxuICAgICdxdWVyaWVzJzogdHJ1ZSxcbiAgICAncm9vdE5vZGUnOiB0cnVlLFxuICAgICdvbGRQcmV2aW91c1NpYmxpbmcnOiB0cnVlLFxuICAgICdvYnNlcnZlT3duQ2hhbmdlcyc6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBNdXRhdGlvblN1bW1hcnk6IE11dGF0aW9uU3VtbWFyeVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9tdXRhdGlvbi1zdW1tYXJ5LmpzIiwidW5kZWZpbmVkXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBSUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBckNBO0FBc0NBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE3RkE7QUFDQTtBQWdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBEQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBK0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2U0E7QUF5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQURBIiwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){"use strict";eval('"use strict";\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _treeMirror = __webpack_require__(/*! ./tree-mirror */ 0);\n\nif ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") {\n  window.TreeMirror = _treeMirror.TreeMirror;\n  window.TreeMirrorClient = _treeMirror.TreeMirrorClient;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiIsIndlYnBhY2s6Ly8vP2Q0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJlZU1pcnJvciwgVHJlZU1pcnJvckNsaWVudCB9IGZyb20gJy4vdHJlZS1taXJyb3InO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikge1xuICB3aW5kb3cuVHJlZU1pcnJvciA9IFRyZWVNaXJyb3I7XG4gIHdpbmRvdy5UcmVlTWlycm9yQ2xpZW50ID0gVHJlZU1pcnJvckNsaWVudDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvaW5kZXguanMiLCJ1bmRlZmluZWRcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUNDQTsiLCJzb3VyY2VSb290IjoiIn0=')}]);